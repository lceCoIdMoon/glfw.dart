// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class GLFW {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  GLFW(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  GLFW.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(uintptr_t)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<uintptr_t> ___security_cookie =
      _lookup<uintptr_t>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<wchar_t> _Expression,
    ffi.Pointer<wchar_t> _FunctionName,
    ffi.Pointer<wchar_t> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
              ffi.Pointer<wchar_t>, ffi.Uint32, uintptr_t)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<wchar_t>, ffi.Pointer<wchar_t>,
          ffi.Pointer<wchar_t>, int, int)>();

  ffi.Pointer<ffi.Int32> _errno() {
    return __errno();
  }

  late final __errnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int32> Function()>>('_errno');
  late final __errno =
      __errnoPtr.asFunction<ffi.Pointer<ffi.Int32> Function()>();

  int _set_errno(
    int _Value,
  ) {
    return __set_errno(
      _Value,
    );
  }

  late final __set_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int32)>>('_set_errno');
  late final __set_errno = __set_errnoPtr.asFunction<int Function(int)>();

  int _get_errno(
    ffi.Pointer<ffi.Int32> _Value,
  ) {
    return __get_errno(
      _Value,
    );
  }

  late final __get_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Int32>)>>(
          '_get_errno');
  late final __get_errno =
      __get_errnoPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  int __threadid() {
    return ___threadid();
  }

  late final ___threadidPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('__threadid');
  late final ___threadid = ___threadidPtr.asFunction<int Function()>();

  int __threadhandle() {
    return ___threadhandle();
  }

  late final ___threadhandlePtr =
      _lookup<ffi.NativeFunction<uintptr_t Function()>>('__threadhandle');
  late final ___threadhandle = ___threadhandlePtr.asFunction<int Function()>();

  void glAccum(
    int op,
    double value,
  ) {
    return _glAccum(
      op,
      value,
    );
  }

  late final _glAccumPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLfloat)>>(
          'glAccum');
  late final _glAccum = _glAccumPtr.asFunction<void Function(int, double)>();

  void glAlphaFunc(
    int func,
    double ref,
  ) {
    return _glAlphaFunc(
      func,
      ref,
    );
  }

  late final _glAlphaFuncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLclampf)>>(
          'glAlphaFunc');
  late final _glAlphaFunc =
      _glAlphaFuncPtr.asFunction<void Function(int, double)>();

  int glAreTexturesResident(
    int n,
    ffi.Pointer<GLuint> textures,
    ffi.Pointer<GLboolean> residences,
  ) {
    return _glAreTexturesResident(
      n,
      textures,
      residences,
    );
  }

  late final _glAreTexturesResidentPtr = _lookup<
      ffi.NativeFunction<
          GLboolean Function(GLsizei, ffi.Pointer<GLuint>,
              ffi.Pointer<GLboolean>)>>('glAreTexturesResident');
  late final _glAreTexturesResident = _glAreTexturesResidentPtr.asFunction<
      int Function(int, ffi.Pointer<GLuint>, ffi.Pointer<GLboolean>)>();

  void glArrayElement(
    int i,
  ) {
    return _glArrayElement(
      i,
    );
  }

  late final _glArrayElementPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint)>>('glArrayElement');
  late final _glArrayElement =
      _glArrayElementPtr.asFunction<void Function(int)>();

  void glBegin(
    int mode,
  ) {
    return _glBegin(
      mode,
    );
  }

  late final _glBeginPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glBegin');
  late final _glBegin = _glBeginPtr.asFunction<void Function(int)>();

  void glBindTexture(
    int target,
    int texture,
  ) {
    return _glBindTexture(
      target,
      texture,
    );
  }

  late final _glBindTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLuint)>>(
          'glBindTexture');
  late final _glBindTexture =
      _glBindTexturePtr.asFunction<void Function(int, int)>();

  void glBitmap(
    int width,
    int height,
    double xorig,
    double yorig,
    double xmove,
    double ymove,
    ffi.Pointer<GLubyte> bitmap,
  ) {
    return _glBitmap(
      width,
      height,
      xorig,
      yorig,
      xmove,
      ymove,
      bitmap,
    );
  }

  late final _glBitmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat,
              GLfloat, ffi.Pointer<GLubyte>)>>('glBitmap');
  late final _glBitmap = _glBitmapPtr.asFunction<
      void Function(
          int, int, double, double, double, double, ffi.Pointer<GLubyte>)>();

  void glBlendFunc(
    int sfactor,
    int dfactor,
  ) {
    return _glBlendFunc(
      sfactor,
      dfactor,
    );
  }

  late final _glBlendFuncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum)>>(
          'glBlendFunc');
  late final _glBlendFunc =
      _glBlendFuncPtr.asFunction<void Function(int, int)>();

  void glCallList(
    int list,
  ) {
    return _glCallList(
      list,
    );
  }

  late final _glCallListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glCallList');
  late final _glCallList = _glCallListPtr.asFunction<void Function(int)>();

  void glCallLists(
    int n,
    int type,
    ffi.Pointer<GLvoid> lists,
  ) {
    return _glCallLists(
      n,
      type,
      lists,
    );
  }

  late final _glCallListsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLsizei, GLenum, ffi.Pointer<GLvoid>)>>('glCallLists');
  late final _glCallLists = _glCallListsPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLvoid>)>();

  void glClear(
    int mask,
  ) {
    return _glClear(
      mask,
    );
  }

  late final _glClearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLbitfield)>>('glClear');
  late final _glClear = _glClearPtr.asFunction<void Function(int)>();

  void glClearAccum(
    double red,
    double green,
    double blue,
    double alpha,
  ) {
    return _glClearAccum(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glClearAccumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLfloat, GLfloat, GLfloat, GLfloat)>>('glClearAccum');
  late final _glClearAccum = _glClearAccumPtr
      .asFunction<void Function(double, double, double, double)>();

  void glClearColor(
    double red,
    double green,
    double blue,
    double alpha,
  ) {
    return _glClearColor(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glClearColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLclampf, GLclampf, GLclampf, GLclampf)>>('glClearColor');
  late final _glClearColor = _glClearColorPtr
      .asFunction<void Function(double, double, double, double)>();

  void glClearDepth(
    double depth,
  ) {
    return _glClearDepth(
      depth,
    );
  }

  late final _glClearDepthPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLclampd)>>('glClearDepth');
  late final _glClearDepth =
      _glClearDepthPtr.asFunction<void Function(double)>();

  void glClearIndex(
    double c,
  ) {
    return _glClearIndex(
      c,
    );
  }

  late final _glClearIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glClearIndex');
  late final _glClearIndex =
      _glClearIndexPtr.asFunction<void Function(double)>();

  void glClearStencil(
    int s,
  ) {
    return _glClearStencil(
      s,
    );
  }

  late final _glClearStencilPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint)>>('glClearStencil');
  late final _glClearStencil =
      _glClearStencilPtr.asFunction<void Function(int)>();

  void glClipPlane(
    int plane,
    ffi.Pointer<GLdouble> equation,
  ) {
    return _glClipPlane(
      plane,
      equation,
    );
  }

  late final _glClipPlanePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLdouble>)>>(
      'glClipPlane');
  late final _glClipPlane =
      _glClipPlanePtr.asFunction<void Function(int, ffi.Pointer<GLdouble>)>();

  void glColor3b(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3b(
      red,
      green,
      blue,
    );
  }

  late final _glColor3bPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLbyte, GLbyte, GLbyte)>>(
          'glColor3b');
  late final _glColor3b =
      _glColor3bPtr.asFunction<void Function(int, int, int)>();

  void glColor3bv(
    ffi.Pointer<GLbyte> v,
  ) {
    return _glColor3bv(
      v,
    );
  }

  late final _glColor3bvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLbyte>)>>(
          'glColor3bv');
  late final _glColor3bv =
      _glColor3bvPtr.asFunction<void Function(ffi.Pointer<GLbyte>)>();

  void glColor3d(
    double red,
    double green,
    double blue,
  ) {
    return _glColor3d(
      red,
      green,
      blue,
    );
  }

  late final _glColor3dPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glColor3d');
  late final _glColor3d =
      _glColor3dPtr.asFunction<void Function(double, double, double)>();

  void glColor3dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glColor3dv(
      v,
    );
  }

  late final _glColor3dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glColor3dv');
  late final _glColor3dv =
      _glColor3dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glColor3f(
    double red,
    double green,
    double blue,
  ) {
    return _glColor3f(
      red,
      green,
      blue,
    );
  }

  late final _glColor3fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glColor3f');
  late final _glColor3f =
      _glColor3fPtr.asFunction<void Function(double, double, double)>();

  void glColor3fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glColor3fv(
      v,
    );
  }

  late final _glColor3fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glColor3fv');
  late final _glColor3fv =
      _glColor3fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glColor3i(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3i(
      red,
      green,
      blue,
    );
  }

  late final _glColor3iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint)>>(
          'glColor3i');
  late final _glColor3i =
      _glColor3iPtr.asFunction<void Function(int, int, int)>();

  void glColor3iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glColor3iv(
      v,
    );
  }

  late final _glColor3ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glColor3iv');
  late final _glColor3iv =
      _glColor3ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glColor3s(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3s(
      red,
      green,
      blue,
    );
  }

  late final _glColor3sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort, GLshort)>>(
          'glColor3s');
  late final _glColor3s =
      _glColor3sPtr.asFunction<void Function(int, int, int)>();

  void glColor3sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glColor3sv(
      v,
    );
  }

  late final _glColor3svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glColor3sv');
  late final _glColor3sv =
      _glColor3svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glColor3ub(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3ub(
      red,
      green,
      blue,
    );
  }

  late final _glColor3ubPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLubyte, GLubyte, GLubyte)>>(
          'glColor3ub');
  late final _glColor3ub =
      _glColor3ubPtr.asFunction<void Function(int, int, int)>();

  void glColor3ubv(
    ffi.Pointer<GLubyte> v,
  ) {
    return _glColor3ubv(
      v,
    );
  }

  late final _glColor3ubvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLubyte>)>>(
          'glColor3ubv');
  late final _glColor3ubv =
      _glColor3ubvPtr.asFunction<void Function(ffi.Pointer<GLubyte>)>();

  void glColor3ui(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3ui(
      red,
      green,
      blue,
    );
  }

  late final _glColor3uiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint, GLuint, GLuint)>>(
          'glColor3ui');
  late final _glColor3ui =
      _glColor3uiPtr.asFunction<void Function(int, int, int)>();

  void glColor3uiv(
    ffi.Pointer<GLuint> v,
  ) {
    return _glColor3uiv(
      v,
    );
  }

  late final _glColor3uivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLuint>)>>(
          'glColor3uiv');
  late final _glColor3uiv =
      _glColor3uivPtr.asFunction<void Function(ffi.Pointer<GLuint>)>();

  void glColor3us(
    int red,
    int green,
    int blue,
  ) {
    return _glColor3us(
      red,
      green,
      blue,
    );
  }

  late final _glColor3usPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLushort, GLushort, GLushort)>>(
      'glColor3us');
  late final _glColor3us =
      _glColor3usPtr.asFunction<void Function(int, int, int)>();

  void glColor3usv(
    ffi.Pointer<GLushort> v,
  ) {
    return _glColor3usv(
      v,
    );
  }

  late final _glColor3usvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLushort>)>>(
          'glColor3usv');
  late final _glColor3usv =
      _glColor3usvPtr.asFunction<void Function(ffi.Pointer<GLushort>)>();

  void glColor4b(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4b(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLbyte, GLbyte, GLbyte, GLbyte)>>('glColor4b');
  late final _glColor4b =
      _glColor4bPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4bv(
    ffi.Pointer<GLbyte> v,
  ) {
    return _glColor4bv(
      v,
    );
  }

  late final _glColor4bvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLbyte>)>>(
          'glColor4bv');
  late final _glColor4bv =
      _glColor4bvPtr.asFunction<void Function(ffi.Pointer<GLbyte>)>();

  void glColor4d(
    double red,
    double green,
    double blue,
    double alpha,
  ) {
    return _glColor4d(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glColor4d');
  late final _glColor4d =
      _glColor4dPtr.asFunction<void Function(double, double, double, double)>();

  void glColor4dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glColor4dv(
      v,
    );
  }

  late final _glColor4dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glColor4dv');
  late final _glColor4dv =
      _glColor4dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glColor4f(
    double red,
    double green,
    double blue,
    double alpha,
  ) {
    return _glColor4f(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLfloat, GLfloat, GLfloat, GLfloat)>>('glColor4f');
  late final _glColor4f =
      _glColor4fPtr.asFunction<void Function(double, double, double, double)>();

  void glColor4fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glColor4fv(
      v,
    );
  }

  late final _glColor4fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glColor4fv');
  late final _glColor4fv =
      _glColor4fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glColor4i(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4i(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4iPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint, GLint)>>(
      'glColor4i');
  late final _glColor4i =
      _glColor4iPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glColor4iv(
      v,
    );
  }

  late final _glColor4ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glColor4iv');
  late final _glColor4iv =
      _glColor4ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glColor4s(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4s(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLshort, GLshort, GLshort, GLshort)>>('glColor4s');
  late final _glColor4s =
      _glColor4sPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glColor4sv(
      v,
    );
  }

  late final _glColor4svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glColor4sv');
  late final _glColor4sv =
      _glColor4svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glColor4ub(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4ub(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4ubPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLubyte, GLubyte, GLubyte, GLubyte)>>('glColor4ub');
  late final _glColor4ub =
      _glColor4ubPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4ubv(
    ffi.Pointer<GLubyte> v,
  ) {
    return _glColor4ubv(
      v,
    );
  }

  late final _glColor4ubvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLubyte>)>>(
          'glColor4ubv');
  late final _glColor4ubv =
      _glColor4ubvPtr.asFunction<void Function(ffi.Pointer<GLubyte>)>();

  void glColor4ui(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4ui(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4uiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLuint, GLuint, GLuint, GLuint)>>('glColor4ui');
  late final _glColor4ui =
      _glColor4uiPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4uiv(
    ffi.Pointer<GLuint> v,
  ) {
    return _glColor4uiv(
      v,
    );
  }

  late final _glColor4uivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLuint>)>>(
          'glColor4uiv');
  late final _glColor4uiv =
      _glColor4uivPtr.asFunction<void Function(ffi.Pointer<GLuint>)>();

  void glColor4us(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColor4us(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColor4usPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLushort, GLushort, GLushort, GLushort)>>('glColor4us');
  late final _glColor4us =
      _glColor4usPtr.asFunction<void Function(int, int, int, int)>();

  void glColor4usv(
    ffi.Pointer<GLushort> v,
  ) {
    return _glColor4usv(
      v,
    );
  }

  late final _glColor4usvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLushort>)>>(
          'glColor4usv');
  late final _glColor4usv =
      _glColor4usvPtr.asFunction<void Function(ffi.Pointer<GLushort>)>();

  void glColorMask(
    int red,
    int green,
    int blue,
    int alpha,
  ) {
    return _glColorMask(
      red,
      green,
      blue,
      alpha,
    );
  }

  late final _glColorMaskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLboolean, GLboolean, GLboolean, GLboolean)>>('glColorMask');
  late final _glColorMask =
      _glColorMaskPtr.asFunction<void Function(int, int, int, int)>();

  void glColorMaterial(
    int face,
    int mode,
  ) {
    return _glColorMaterial(
      face,
      mode,
    );
  }

  late final _glColorMaterialPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum)>>(
          'glColorMaterial');
  late final _glColorMaterial =
      _glColorMaterialPtr.asFunction<void Function(int, int)>();

  void glColorPointer(
    int size,
    int type,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glColorPointer(
      size,
      type,
      stride,
      pointer,
    );
  }

  late final _glColorPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLint, GLenum, GLsizei, ffi.Pointer<GLvoid>)>>('glColorPointer');
  late final _glColorPointer = _glColorPointerPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLvoid>)>();

  void glCopyPixels(
    int x,
    int y,
    int width,
    int height,
    int type,
  ) {
    return _glCopyPixels(
      x,
      y,
      width,
      height,
      type,
    );
  }

  late final _glCopyPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLint, GLint, GLsizei, GLsizei, GLenum)>>('glCopyPixels');
  late final _glCopyPixels =
      _glCopyPixelsPtr.asFunction<void Function(int, int, int, int, int)>();

  void glCopyTexImage1D(
    int target,
    int level,
    int internalFormat,
    int x,
    int y,
    int width,
    int border,
  ) {
    return _glCopyTexImage1D(
      target,
      level,
      internalFormat,
      x,
      y,
      width,
      border,
    );
  }

  late final _glCopyTexImage1DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLenum, GLint, GLint, GLsizei,
              GLint)>>('glCopyTexImage1D');
  late final _glCopyTexImage1D = _glCopyTexImage1DPtr
      .asFunction<void Function(int, int, int, int, int, int, int)>();

  void glCopyTexImage2D(
    int target,
    int level,
    int internalFormat,
    int x,
    int y,
    int width,
    int height,
    int border,
  ) {
    return _glCopyTexImage2D(
      target,
      level,
      internalFormat,
      x,
      y,
      width,
      height,
      border,
    );
  }

  late final _glCopyTexImage2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLenum, GLint, GLint, GLsizei,
              GLsizei, GLint)>>('glCopyTexImage2D');
  late final _glCopyTexImage2D = _glCopyTexImage2DPtr
      .asFunction<void Function(int, int, int, int, int, int, int, int)>();

  void glCopyTexSubImage1D(
    int target,
    int level,
    int xoffset,
    int x,
    int y,
    int width,
  ) {
    return _glCopyTexSubImage1D(
      target,
      level,
      xoffset,
      x,
      y,
      width,
    );
  }

  late final _glCopyTexSubImage1DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLint, GLint,
              GLsizei)>>('glCopyTexSubImage1D');
  late final _glCopyTexSubImage1D = _glCopyTexSubImage1DPtr
      .asFunction<void Function(int, int, int, int, int, int)>();

  void glCopyTexSubImage2D(
    int target,
    int level,
    int xoffset,
    int yoffset,
    int x,
    int y,
    int width,
    int height,
  ) {
    return _glCopyTexSubImage2D(
      target,
      level,
      xoffset,
      yoffset,
      x,
      y,
      width,
      height,
    );
  }

  late final _glCopyTexSubImage2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei,
              GLsizei)>>('glCopyTexSubImage2D');
  late final _glCopyTexSubImage2D = _glCopyTexSubImage2DPtr
      .asFunction<void Function(int, int, int, int, int, int, int, int)>();

  void glCullFace(
    int mode,
  ) {
    return _glCullFace(
      mode,
    );
  }

  late final _glCullFacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glCullFace');
  late final _glCullFace = _glCullFacePtr.asFunction<void Function(int)>();

  void glDeleteLists(
    int list,
    int range,
  ) {
    return _glDeleteLists(
      list,
      range,
    );
  }

  late final _glDeleteListsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint, GLsizei)>>(
          'glDeleteLists');
  late final _glDeleteLists =
      _glDeleteListsPtr.asFunction<void Function(int, int)>();

  void glDeleteTextures(
    int n,
    ffi.Pointer<GLuint> textures,
  ) {
    return _glDeleteTextures(
      n,
      textures,
    );
  }

  late final _glDeleteTexturesPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLsizei, ffi.Pointer<GLuint>)>>(
      'glDeleteTextures');
  late final _glDeleteTextures = _glDeleteTexturesPtr
      .asFunction<void Function(int, ffi.Pointer<GLuint>)>();

  void glDepthFunc(
    int func,
  ) {
    return _glDepthFunc(
      func,
    );
  }

  late final _glDepthFuncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glDepthFunc');
  late final _glDepthFunc = _glDepthFuncPtr.asFunction<void Function(int)>();

  void glDepthMask(
    int flag,
  ) {
    return _glDepthMask(
      flag,
    );
  }

  late final _glDepthMaskPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLboolean)>>('glDepthMask');
  late final _glDepthMask = _glDepthMaskPtr.asFunction<void Function(int)>();

  void glDepthRange(
    double zNear,
    double zFar,
  ) {
    return _glDepthRange(
      zNear,
      zFar,
    );
  }

  late final _glDepthRangePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLclampd, GLclampd)>>(
          'glDepthRange');
  late final _glDepthRange =
      _glDepthRangePtr.asFunction<void Function(double, double)>();

  void glDisable(
    int cap,
  ) {
    return _glDisable(
      cap,
    );
  }

  late final _glDisablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glDisable');
  late final _glDisable = _glDisablePtr.asFunction<void Function(int)>();

  void glDisableClientState(
    int array,
  ) {
    return _glDisableClientState(
      array,
    );
  }

  late final _glDisableClientStatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>(
          'glDisableClientState');
  late final _glDisableClientState =
      _glDisableClientStatePtr.asFunction<void Function(int)>();

  void glDrawArrays(
    int mode,
    int first,
    int count,
  ) {
    return _glDrawArrays(
      mode,
      first,
      count,
    );
  }

  late final _glDrawArraysPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint, GLsizei)>>(
          'glDrawArrays');
  late final _glDrawArrays =
      _glDrawArraysPtr.asFunction<void Function(int, int, int)>();

  void glDrawBuffer(
    int mode,
  ) {
    return _glDrawBuffer(
      mode,
    );
  }

  late final _glDrawBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glDrawBuffer');
  late final _glDrawBuffer = _glDrawBufferPtr.asFunction<void Function(int)>();

  void glDrawElements(
    int mode,
    int count,
    int type,
    ffi.Pointer<GLvoid> indices,
  ) {
    return _glDrawElements(
      mode,
      count,
      type,
      indices,
    );
  }

  late final _glDrawElementsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, GLenum, ffi.Pointer<GLvoid>)>>('glDrawElements');
  late final _glDrawElements = _glDrawElementsPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLvoid>)>();

  void glDrawPixels(
    int width,
    int height,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glDrawPixels(
      width,
      height,
      format,
      type,
      pixels,
    );
  }

  late final _glDrawPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLsizei, GLsizei, GLenum, GLenum,
              ffi.Pointer<GLvoid>)>>('glDrawPixels');
  late final _glDrawPixels = _glDrawPixelsPtr
      .asFunction<void Function(int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glEdgeFlag(
    int flag,
  ) {
    return _glEdgeFlag(
      flag,
    );
  }

  late final _glEdgeFlagPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLboolean)>>('glEdgeFlag');
  late final _glEdgeFlag = _glEdgeFlagPtr.asFunction<void Function(int)>();

  void glEdgeFlagPointer(
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glEdgeFlagPointer(
      stride,
      pointer,
    );
  }

  late final _glEdgeFlagPointerPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLsizei, ffi.Pointer<GLvoid>)>>(
      'glEdgeFlagPointer');
  late final _glEdgeFlagPointer = _glEdgeFlagPointerPtr
      .asFunction<void Function(int, ffi.Pointer<GLvoid>)>();

  void glEdgeFlagv(
    ffi.Pointer<GLboolean> flag,
  ) {
    return _glEdgeFlagv(
      flag,
    );
  }

  late final _glEdgeFlagvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLboolean>)>>(
          'glEdgeFlagv');
  late final _glEdgeFlagv =
      _glEdgeFlagvPtr.asFunction<void Function(ffi.Pointer<GLboolean>)>();

  void glEnable(
    int cap,
  ) {
    return _glEnable(
      cap,
    );
  }

  late final _glEnablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glEnable');
  late final _glEnable = _glEnablePtr.asFunction<void Function(int)>();

  void glEnableClientState(
    int array,
  ) {
    return _glEnableClientState(
      array,
    );
  }

  late final _glEnableClientStatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>(
          'glEnableClientState');
  late final _glEnableClientState =
      _glEnableClientStatePtr.asFunction<void Function(int)>();

  void glEnd() {
    return _glEnd();
  }

  late final _glEndPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glEnd');
  late final _glEnd = _glEndPtr.asFunction<void Function()>();

  void glEndList() {
    return _glEndList();
  }

  late final _glEndListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glEndList');
  late final _glEndList = _glEndListPtr.asFunction<void Function()>();

  void glEvalCoord1d(
    double u,
  ) {
    return _glEvalCoord1d(
      u,
    );
  }

  late final _glEvalCoord1dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble)>>('glEvalCoord1d');
  late final _glEvalCoord1d =
      _glEvalCoord1dPtr.asFunction<void Function(double)>();

  void glEvalCoord1dv(
    ffi.Pointer<GLdouble> u,
  ) {
    return _glEvalCoord1dv(
      u,
    );
  }

  late final _glEvalCoord1dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glEvalCoord1dv');
  late final _glEvalCoord1dv =
      _glEvalCoord1dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glEvalCoord1f(
    double u,
  ) {
    return _glEvalCoord1f(
      u,
    );
  }

  late final _glEvalCoord1fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glEvalCoord1f');
  late final _glEvalCoord1f =
      _glEvalCoord1fPtr.asFunction<void Function(double)>();

  void glEvalCoord1fv(
    ffi.Pointer<GLfloat> u,
  ) {
    return _glEvalCoord1fv(
      u,
    );
  }

  late final _glEvalCoord1fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glEvalCoord1fv');
  late final _glEvalCoord1fv =
      _glEvalCoord1fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glEvalCoord2d(
    double u,
    double v,
  ) {
    return _glEvalCoord2d(
      u,
      v,
    );
  }

  late final _glEvalCoord2dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble)>>(
          'glEvalCoord2d');
  late final _glEvalCoord2d =
      _glEvalCoord2dPtr.asFunction<void Function(double, double)>();

  void glEvalCoord2dv(
    ffi.Pointer<GLdouble> u,
  ) {
    return _glEvalCoord2dv(
      u,
    );
  }

  late final _glEvalCoord2dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glEvalCoord2dv');
  late final _glEvalCoord2dv =
      _glEvalCoord2dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glEvalCoord2f(
    double u,
    double v,
  ) {
    return _glEvalCoord2f(
      u,
      v,
    );
  }

  late final _glEvalCoord2fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glEvalCoord2f');
  late final _glEvalCoord2f =
      _glEvalCoord2fPtr.asFunction<void Function(double, double)>();

  void glEvalCoord2fv(
    ffi.Pointer<GLfloat> u,
  ) {
    return _glEvalCoord2fv(
      u,
    );
  }

  late final _glEvalCoord2fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glEvalCoord2fv');
  late final _glEvalCoord2fv =
      _glEvalCoord2fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glEvalMesh1(
    int mode,
    int i1,
    int i2,
  ) {
    return _glEvalMesh1(
      mode,
      i1,
      i2,
    );
  }

  late final _glEvalMesh1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint, GLint)>>(
          'glEvalMesh1');
  late final _glEvalMesh1 =
      _glEvalMesh1Ptr.asFunction<void Function(int, int, int)>();

  void glEvalMesh2(
    int mode,
    int i1,
    int i2,
    int j1,
    int j2,
  ) {
    return _glEvalMesh2(
      mode,
      i1,
      i2,
      j1,
      j2,
    );
  }

  late final _glEvalMesh2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLint, GLint, GLint, GLint)>>('glEvalMesh2');
  late final _glEvalMesh2 =
      _glEvalMesh2Ptr.asFunction<void Function(int, int, int, int, int)>();

  void glEvalPoint1(
    int i,
  ) {
    return _glEvalPoint1(
      i,
    );
  }

  late final _glEvalPoint1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint)>>('glEvalPoint1');
  late final _glEvalPoint1 = _glEvalPoint1Ptr.asFunction<void Function(int)>();

  void glEvalPoint2(
    int i,
    int j,
  ) {
    return _glEvalPoint2(
      i,
      j,
    );
  }

  late final _glEvalPoint2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint)>>(
          'glEvalPoint2');
  late final _glEvalPoint2 =
      _glEvalPoint2Ptr.asFunction<void Function(int, int)>();

  void glFeedbackBuffer(
    int size,
    int type,
    ffi.Pointer<GLfloat> buffer,
  ) {
    return _glFeedbackBuffer(
      size,
      type,
      buffer,
    );
  }

  late final _glFeedbackBufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLsizei, GLenum, ffi.Pointer<GLfloat>)>>('glFeedbackBuffer');
  late final _glFeedbackBuffer = _glFeedbackBufferPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glFinish() {
    return _glFinish();
  }

  late final _glFinishPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glFinish');
  late final _glFinish = _glFinishPtr.asFunction<void Function()>();

  void glFlush() {
    return _glFlush();
  }

  late final _glFlushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glFlush');
  late final _glFlush = _glFlushPtr.asFunction<void Function()>();

  void glFogf(
    int pname,
    double param,
  ) {
    return _glFogf(
      pname,
      param,
    );
  }

  late final _glFogfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLfloat)>>('glFogf');
  late final _glFogf = _glFogfPtr.asFunction<void Function(int, double)>();

  void glFogfv(
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glFogfv(
      pname,
      params,
    );
  }

  late final _glFogfvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLfloat>)>>(
      'glFogfv');
  late final _glFogfv =
      _glFogfvPtr.asFunction<void Function(int, ffi.Pointer<GLfloat>)>();

  void glFogi(
    int pname,
    int param,
  ) {
    return _glFogi(
      pname,
      param,
    );
  }

  late final _glFogiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint)>>('glFogi');
  late final _glFogi = _glFogiPtr.asFunction<void Function(int, int)>();

  void glFogiv(
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glFogiv(
      pname,
      params,
    );
  }

  late final _glFogivPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLint>)>>(
      'glFogiv');
  late final _glFogiv =
      _glFogivPtr.asFunction<void Function(int, ffi.Pointer<GLint>)>();

  void glFrontFace(
    int mode,
  ) {
    return _glFrontFace(
      mode,
    );
  }

  late final _glFrontFacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glFrontFace');
  late final _glFrontFace = _glFrontFacePtr.asFunction<void Function(int)>();

  void glFrustum(
    double left,
    double right,
    double bottom,
    double top,
    double zNear,
    double zFar,
  ) {
    return _glFrustum(
      left,
      right,
      bottom,
      top,
      zNear,
      zFar,
    );
  }

  late final _glFrustumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble,
              GLdouble)>>('glFrustum');
  late final _glFrustum = _glFrustumPtr.asFunction<
      void Function(double, double, double, double, double, double)>();

  int glGenLists(
    int range,
  ) {
    return _glGenLists(
      range,
    );
  }

  late final _glGenListsPtr =
      _lookup<ffi.NativeFunction<GLuint Function(GLsizei)>>('glGenLists');
  late final _glGenLists = _glGenListsPtr.asFunction<int Function(int)>();

  void glGenTextures(
    int n,
    ffi.Pointer<GLuint> textures,
  ) {
    return _glGenTextures(
      n,
      textures,
    );
  }

  late final _glGenTexturesPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLsizei, ffi.Pointer<GLuint>)>>(
      'glGenTextures');
  late final _glGenTextures =
      _glGenTexturesPtr.asFunction<void Function(int, ffi.Pointer<GLuint>)>();

  void glGetBooleanv(
    int pname,
    ffi.Pointer<GLboolean> params,
  ) {
    return _glGetBooleanv(
      pname,
      params,
    );
  }

  late final _glGetBooleanvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, ffi.Pointer<GLboolean>)>>('glGetBooleanv');
  late final _glGetBooleanv = _glGetBooleanvPtr
      .asFunction<void Function(int, ffi.Pointer<GLboolean>)>();

  void glGetClipPlane(
    int plane,
    ffi.Pointer<GLdouble> equation,
  ) {
    return _glGetClipPlane(
      plane,
      equation,
    );
  }

  late final _glGetClipPlanePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLdouble>)>>(
      'glGetClipPlane');
  late final _glGetClipPlane = _glGetClipPlanePtr
      .asFunction<void Function(int, ffi.Pointer<GLdouble>)>();

  void glGetDoublev(
    int pname,
    ffi.Pointer<GLdouble> params,
  ) {
    return _glGetDoublev(
      pname,
      params,
    );
  }

  late final _glGetDoublevPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLdouble>)>>(
      'glGetDoublev');
  late final _glGetDoublev =
      _glGetDoublevPtr.asFunction<void Function(int, ffi.Pointer<GLdouble>)>();

  int glGetError() {
    return _glGetError();
  }

  late final _glGetErrorPtr =
      _lookup<ffi.NativeFunction<GLenum Function()>>('glGetError');
  late final _glGetError = _glGetErrorPtr.asFunction<int Function()>();

  void glGetFloatv(
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetFloatv(
      pname,
      params,
    );
  }

  late final _glGetFloatvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLfloat>)>>(
      'glGetFloatv');
  late final _glGetFloatv =
      _glGetFloatvPtr.asFunction<void Function(int, ffi.Pointer<GLfloat>)>();

  void glGetIntegerv(
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetIntegerv(
      pname,
      params,
    );
  }

  late final _glGetIntegervPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLint>)>>(
      'glGetIntegerv');
  late final _glGetIntegerv =
      _glGetIntegervPtr.asFunction<void Function(int, ffi.Pointer<GLint>)>();

  void glGetLightfv(
    int light,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetLightfv(
      light,
      pname,
      params,
    );
  }

  late final _glGetLightfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetLightfv');
  late final _glGetLightfv = _glGetLightfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetLightiv(
    int light,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetLightiv(
      light,
      pname,
      params,
    );
  }

  late final _glGetLightivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetLightiv');
  late final _glGetLightiv = _glGetLightivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glGetMapdv(
    int target,
    int query,
    ffi.Pointer<GLdouble> v,
  ) {
    return _glGetMapdv(
      target,
      query,
      v,
    );
  }

  late final _glGetMapdvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLdouble>)>>('glGetMapdv');
  late final _glGetMapdv = _glGetMapdvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLdouble>)>();

  void glGetMapfv(
    int target,
    int query,
    ffi.Pointer<GLfloat> v,
  ) {
    return _glGetMapfv(
      target,
      query,
      v,
    );
  }

  late final _glGetMapfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetMapfv');
  late final _glGetMapfv = _glGetMapfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetMapiv(
    int target,
    int query,
    ffi.Pointer<GLint> v,
  ) {
    return _glGetMapiv(
      target,
      query,
      v,
    );
  }

  late final _glGetMapivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetMapiv');
  late final _glGetMapiv =
      _glGetMapivPtr.asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glGetMaterialfv(
    int face,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetMaterialfv(
      face,
      pname,
      params,
    );
  }

  late final _glGetMaterialfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetMaterialfv');
  late final _glGetMaterialfv = _glGetMaterialfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetMaterialiv(
    int face,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetMaterialiv(
      face,
      pname,
      params,
    );
  }

  late final _glGetMaterialivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetMaterialiv');
  late final _glGetMaterialiv = _glGetMaterialivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glGetPixelMapfv(
    int map,
    ffi.Pointer<GLfloat> values,
  ) {
    return _glGetPixelMapfv(
      map,
      values,
    );
  }

  late final _glGetPixelMapfvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLfloat>)>>(
      'glGetPixelMapfv');
  late final _glGetPixelMapfv = _glGetPixelMapfvPtr
      .asFunction<void Function(int, ffi.Pointer<GLfloat>)>();

  void glGetPixelMapuiv(
    int map,
    ffi.Pointer<GLuint> values,
  ) {
    return _glGetPixelMapuiv(
      map,
      values,
    );
  }

  late final _glGetPixelMapuivPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLuint>)>>(
      'glGetPixelMapuiv');
  late final _glGetPixelMapuiv = _glGetPixelMapuivPtr
      .asFunction<void Function(int, ffi.Pointer<GLuint>)>();

  void glGetPixelMapusv(
    int map,
    ffi.Pointer<GLushort> values,
  ) {
    return _glGetPixelMapusv(
      map,
      values,
    );
  }

  late final _glGetPixelMapusvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLushort>)>>(
      'glGetPixelMapusv');
  late final _glGetPixelMapusv = _glGetPixelMapusvPtr
      .asFunction<void Function(int, ffi.Pointer<GLushort>)>();

  void glGetPointerv(
    int pname,
    ffi.Pointer<ffi.Pointer<GLvoid>> params,
  ) {
    return _glGetPointerv(
      pname,
      params,
    );
  }

  late final _glGetPointervPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, ffi.Pointer<ffi.Pointer<GLvoid>>)>>('glGetPointerv');
  late final _glGetPointerv = _glGetPointervPtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Pointer<GLvoid>>)>();

  void glGetPolygonStipple(
    ffi.Pointer<GLubyte> mask,
  ) {
    return _glGetPolygonStipple(
      mask,
    );
  }

  late final _glGetPolygonStipplePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLubyte>)>>(
          'glGetPolygonStipple');
  late final _glGetPolygonStipple =
      _glGetPolygonStipplePtr.asFunction<void Function(ffi.Pointer<GLubyte>)>();

  ffi.Pointer<GLubyte> glGetString(
    int name,
  ) {
    return _glGetString(
      name,
    );
  }

  late final _glGetStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GLubyte> Function(GLenum)>>(
          'glGetString');
  late final _glGetString =
      _glGetStringPtr.asFunction<ffi.Pointer<GLubyte> Function(int)>();

  void glGetTexEnvfv(
    int target,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetTexEnvfv(
      target,
      pname,
      params,
    );
  }

  late final _glGetTexEnvfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetTexEnvfv');
  late final _glGetTexEnvfv = _glGetTexEnvfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetTexEnviv(
    int target,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetTexEnviv(
      target,
      pname,
      params,
    );
  }

  late final _glGetTexEnvivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetTexEnviv');
  late final _glGetTexEnviv = _glGetTexEnvivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glGetTexGendv(
    int coord,
    int pname,
    ffi.Pointer<GLdouble> params,
  ) {
    return _glGetTexGendv(
      coord,
      pname,
      params,
    );
  }

  late final _glGetTexGendvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLdouble>)>>('glGetTexGendv');
  late final _glGetTexGendv = _glGetTexGendvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLdouble>)>();

  void glGetTexGenfv(
    int coord,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetTexGenfv(
      coord,
      pname,
      params,
    );
  }

  late final _glGetTexGenfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetTexGenfv');
  late final _glGetTexGenfv = _glGetTexGenfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetTexGeniv(
    int coord,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetTexGeniv(
      coord,
      pname,
      params,
    );
  }

  late final _glGetTexGenivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetTexGeniv');
  late final _glGetTexGeniv = _glGetTexGenivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glGetTexImage(
    int target,
    int level,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glGetTexImage(
      target,
      level,
      format,
      type,
      pixels,
    );
  }

  late final _glGetTexImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLenum, GLenum,
              ffi.Pointer<GLvoid>)>>('glGetTexImage');
  late final _glGetTexImage = _glGetTexImagePtr
      .asFunction<void Function(int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glGetTexLevelParameterfv(
    int target,
    int level,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetTexLevelParameterfv(
      target,
      level,
      pname,
      params,
    );
  }

  late final _glGetTexLevelParameterfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLenum,
              ffi.Pointer<GLfloat>)>>('glGetTexLevelParameterfv');
  late final _glGetTexLevelParameterfv = _glGetTexLevelParameterfvPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLfloat>)>();

  void glGetTexLevelParameteriv(
    int target,
    int level,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetTexLevelParameteriv(
      target,
      level,
      pname,
      params,
    );
  }

  late final _glGetTexLevelParameterivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLenum,
              ffi.Pointer<GLint>)>>('glGetTexLevelParameteriv');
  late final _glGetTexLevelParameteriv = _glGetTexLevelParameterivPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLint>)>();

  void glGetTexParameterfv(
    int target,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glGetTexParameterfv(
      target,
      pname,
      params,
    );
  }

  late final _glGetTexParameterfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glGetTexParameterfv');
  late final _glGetTexParameterfv = _glGetTexParameterfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glGetTexParameteriv(
    int target,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glGetTexParameteriv(
      target,
      pname,
      params,
    );
  }

  late final _glGetTexParameterivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glGetTexParameteriv');
  late final _glGetTexParameteriv = _glGetTexParameterivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glHint(
    int target,
    int mode,
  ) {
    return _glHint(
      target,
      mode,
    );
  }

  late final _glHintPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum)>>('glHint');
  late final _glHint = _glHintPtr.asFunction<void Function(int, int)>();

  void glIndexMask(
    int mask,
  ) {
    return _glIndexMask(
      mask,
    );
  }

  late final _glIndexMaskPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glIndexMask');
  late final _glIndexMask = _glIndexMaskPtr.asFunction<void Function(int)>();

  void glIndexPointer(
    int type,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glIndexPointer(
      type,
      stride,
      pointer,
    );
  }

  late final _glIndexPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLvoid>)>>('glIndexPointer');
  late final _glIndexPointer = _glIndexPointerPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLvoid>)>();

  void glIndexd(
    double c,
  ) {
    return _glIndexd(
      c,
    );
  }

  late final _glIndexdPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble)>>('glIndexd');
  late final _glIndexd = _glIndexdPtr.asFunction<void Function(double)>();

  void glIndexdv(
    ffi.Pointer<GLdouble> c,
  ) {
    return _glIndexdv(
      c,
    );
  }

  late final _glIndexdvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glIndexdv');
  late final _glIndexdv =
      _glIndexdvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glIndexf(
    double c,
  ) {
    return _glIndexf(
      c,
    );
  }

  late final _glIndexfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glIndexf');
  late final _glIndexf = _glIndexfPtr.asFunction<void Function(double)>();

  void glIndexfv(
    ffi.Pointer<GLfloat> c,
  ) {
    return _glIndexfv(
      c,
    );
  }

  late final _glIndexfvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glIndexfv');
  late final _glIndexfv =
      _glIndexfvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glIndexi(
    int c,
  ) {
    return _glIndexi(
      c,
    );
  }

  late final _glIndexiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint)>>('glIndexi');
  late final _glIndexi = _glIndexiPtr.asFunction<void Function(int)>();

  void glIndexiv(
    ffi.Pointer<GLint> c,
  ) {
    return _glIndexiv(
      c,
    );
  }

  late final _glIndexivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glIndexiv');
  late final _glIndexiv =
      _glIndexivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glIndexs(
    int c,
  ) {
    return _glIndexs(
      c,
    );
  }

  late final _glIndexsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort)>>('glIndexs');
  late final _glIndexs = _glIndexsPtr.asFunction<void Function(int)>();

  void glIndexsv(
    ffi.Pointer<GLshort> c,
  ) {
    return _glIndexsv(
      c,
    );
  }

  late final _glIndexsvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glIndexsv');
  late final _glIndexsv =
      _glIndexsvPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glIndexub(
    int c,
  ) {
    return _glIndexub(
      c,
    );
  }

  late final _glIndexubPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLubyte)>>('glIndexub');
  late final _glIndexub = _glIndexubPtr.asFunction<void Function(int)>();

  void glIndexubv(
    ffi.Pointer<GLubyte> c,
  ) {
    return _glIndexubv(
      c,
    );
  }

  late final _glIndexubvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLubyte>)>>(
          'glIndexubv');
  late final _glIndexubv =
      _glIndexubvPtr.asFunction<void Function(ffi.Pointer<GLubyte>)>();

  void glInitNames() {
    return _glInitNames();
  }

  late final _glInitNamesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glInitNames');
  late final _glInitNames = _glInitNamesPtr.asFunction<void Function()>();

  void glInterleavedArrays(
    int format,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glInterleavedArrays(
      format,
      stride,
      pointer,
    );
  }

  late final _glInterleavedArraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLvoid>)>>('glInterleavedArrays');
  late final _glInterleavedArrays = _glInterleavedArraysPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLvoid>)>();

  int glIsEnabled(
    int cap,
  ) {
    return _glIsEnabled(
      cap,
    );
  }

  late final _glIsEnabledPtr =
      _lookup<ffi.NativeFunction<GLboolean Function(GLenum)>>('glIsEnabled');
  late final _glIsEnabled = _glIsEnabledPtr.asFunction<int Function(int)>();

  int glIsList(
    int list,
  ) {
    return _glIsList(
      list,
    );
  }

  late final _glIsListPtr =
      _lookup<ffi.NativeFunction<GLboolean Function(GLuint)>>('glIsList');
  late final _glIsList = _glIsListPtr.asFunction<int Function(int)>();

  int glIsTexture(
    int texture,
  ) {
    return _glIsTexture(
      texture,
    );
  }

  late final _glIsTexturePtr =
      _lookup<ffi.NativeFunction<GLboolean Function(GLuint)>>('glIsTexture');
  late final _glIsTexture = _glIsTexturePtr.asFunction<int Function(int)>();

  void glLightModelf(
    int pname,
    double param,
  ) {
    return _glLightModelf(
      pname,
      param,
    );
  }

  late final _glLightModelfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLfloat)>>(
          'glLightModelf');
  late final _glLightModelf =
      _glLightModelfPtr.asFunction<void Function(int, double)>();

  void glLightModelfv(
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glLightModelfv(
      pname,
      params,
    );
  }

  late final _glLightModelfvPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLfloat>)>>(
      'glLightModelfv');
  late final _glLightModelfv =
      _glLightModelfvPtr.asFunction<void Function(int, ffi.Pointer<GLfloat>)>();

  void glLightModeli(
    int pname,
    int param,
  ) {
    return _glLightModeli(
      pname,
      param,
    );
  }

  late final _glLightModeliPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint)>>(
          'glLightModeli');
  late final _glLightModeli =
      _glLightModeliPtr.asFunction<void Function(int, int)>();

  void glLightModeliv(
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glLightModeliv(
      pname,
      params,
    );
  }

  late final _glLightModelivPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLenum, ffi.Pointer<GLint>)>>(
      'glLightModeliv');
  late final _glLightModeliv =
      _glLightModelivPtr.asFunction<void Function(int, ffi.Pointer<GLint>)>();

  void glLightf(
    int light,
    int pname,
    double param,
  ) {
    return _glLightf(
      light,
      pname,
      param,
    );
  }

  late final _glLightfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLfloat)>>(
          'glLightf');
  late final _glLightf =
      _glLightfPtr.asFunction<void Function(int, int, double)>();

  void glLightfv(
    int light,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glLightfv(
      light,
      pname,
      params,
    );
  }

  late final _glLightfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glLightfv');
  late final _glLightfv =
      _glLightfvPtr.asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glLighti(
    int light,
    int pname,
    int param,
  ) {
    return _glLighti(
      light,
      pname,
      param,
    );
  }

  late final _glLightiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLint)>>(
          'glLighti');
  late final _glLighti =
      _glLightiPtr.asFunction<void Function(int, int, int)>();

  void glLightiv(
    int light,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glLightiv(
      light,
      pname,
      params,
    );
  }

  late final _glLightivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLenum, ffi.Pointer<GLint>)>>('glLightiv');
  late final _glLightiv =
      _glLightivPtr.asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glLineStipple(
    int factor,
    int pattern,
  ) {
    return _glLineStipple(
      factor,
      pattern,
    );
  }

  late final _glLineStipplePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLushort)>>(
          'glLineStipple');
  late final _glLineStipple =
      _glLineStipplePtr.asFunction<void Function(int, int)>();

  void glLineWidth(
    double width,
  ) {
    return _glLineWidth(
      width,
    );
  }

  late final _glLineWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glLineWidth');
  late final _glLineWidth = _glLineWidthPtr.asFunction<void Function(double)>();

  void glListBase(
    int base,
  ) {
    return _glListBase(
      base,
    );
  }

  late final _glListBasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glListBase');
  late final _glListBase = _glListBasePtr.asFunction<void Function(int)>();

  void glLoadIdentity() {
    return _glLoadIdentity();
  }

  late final _glLoadIdentityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glLoadIdentity');
  late final _glLoadIdentity = _glLoadIdentityPtr.asFunction<void Function()>();

  void glLoadMatrixd(
    ffi.Pointer<GLdouble> m,
  ) {
    return _glLoadMatrixd(
      m,
    );
  }

  late final _glLoadMatrixdPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glLoadMatrixd');
  late final _glLoadMatrixd =
      _glLoadMatrixdPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glLoadMatrixf(
    ffi.Pointer<GLfloat> m,
  ) {
    return _glLoadMatrixf(
      m,
    );
  }

  late final _glLoadMatrixfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glLoadMatrixf');
  late final _glLoadMatrixf =
      _glLoadMatrixfPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glLoadName(
    int name,
  ) {
    return _glLoadName(
      name,
    );
  }

  late final _glLoadNamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glLoadName');
  late final _glLoadName = _glLoadNamePtr.asFunction<void Function(int)>();

  void glLogicOp(
    int opcode,
  ) {
    return _glLogicOp(
      opcode,
    );
  }

  late final _glLogicOpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glLogicOp');
  late final _glLogicOp = _glLogicOpPtr.asFunction<void Function(int)>();

  void glMap1d(
    int target,
    double u1,
    double u2,
    int stride,
    int order,
    ffi.Pointer<GLdouble> points,
  ) {
    return _glMap1d(
      target,
      u1,
      u2,
      stride,
      order,
      points,
    );
  }

  late final _glMap1dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLdouble, GLdouble, GLint, GLint,
              ffi.Pointer<GLdouble>)>>('glMap1d');
  late final _glMap1d = _glMap1dPtr.asFunction<
      void Function(int, double, double, int, int, ffi.Pointer<GLdouble>)>();

  void glMap1f(
    int target,
    double u1,
    double u2,
    int stride,
    int order,
    ffi.Pointer<GLfloat> points,
  ) {
    return _glMap1f(
      target,
      u1,
      u2,
      stride,
      order,
      points,
    );
  }

  late final _glMap1fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLfloat, GLfloat, GLint, GLint,
              ffi.Pointer<GLfloat>)>>('glMap1f');
  late final _glMap1f = _glMap1fPtr.asFunction<
      void Function(int, double, double, int, int, ffi.Pointer<GLfloat>)>();

  void glMap2d(
    int target,
    double u1,
    double u2,
    int ustride,
    int uorder,
    double v1,
    double v2,
    int vstride,
    int vorder,
    ffi.Pointer<GLdouble> points,
  ) {
    return _glMap2d(
      target,
      u1,
      u2,
      ustride,
      uorder,
      v1,
      v2,
      vstride,
      vorder,
      points,
    );
  }

  late final _glMap2dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble,
              GLdouble, GLint, GLint, ffi.Pointer<GLdouble>)>>('glMap2d');
  late final _glMap2d = _glMap2dPtr.asFunction<
      void Function(int, double, double, int, int, double, double, int, int,
          ffi.Pointer<GLdouble>)>();

  void glMap2f(
    int target,
    double u1,
    double u2,
    int ustride,
    int uorder,
    double v1,
    double v2,
    int vstride,
    int vorder,
    ffi.Pointer<GLfloat> points,
  ) {
    return _glMap2f(
      target,
      u1,
      u2,
      ustride,
      uorder,
      v1,
      v2,
      vstride,
      vorder,
      points,
    );
  }

  late final _glMap2fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat,
              GLfloat, GLint, GLint, ffi.Pointer<GLfloat>)>>('glMap2f');
  late final _glMap2f = _glMap2fPtr.asFunction<
      void Function(int, double, double, int, int, double, double, int, int,
          ffi.Pointer<GLfloat>)>();

  void glMapGrid1d(
    int un,
    double u1,
    double u2,
  ) {
    return _glMapGrid1d(
      un,
      u1,
      u2,
    );
  }

  late final _glMapGrid1dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLdouble, GLdouble)>>(
          'glMapGrid1d');
  late final _glMapGrid1d =
      _glMapGrid1dPtr.asFunction<void Function(int, double, double)>();

  void glMapGrid1f(
    int un,
    double u1,
    double u2,
  ) {
    return _glMapGrid1f(
      un,
      u1,
      u2,
    );
  }

  late final _glMapGrid1fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLfloat, GLfloat)>>(
          'glMapGrid1f');
  late final _glMapGrid1f =
      _glMapGrid1fPtr.asFunction<void Function(int, double, double)>();

  void glMapGrid2d(
    int un,
    double u1,
    double u2,
    int vn,
    double v1,
    double v2,
  ) {
    return _glMapGrid2d(
      un,
      u1,
      u2,
      vn,
      v1,
      v2,
    );
  }

  late final _glMapGrid2dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLdouble, GLdouble, GLint, GLdouble,
              GLdouble)>>('glMapGrid2d');
  late final _glMapGrid2d = _glMapGrid2dPtr
      .asFunction<void Function(int, double, double, int, double, double)>();

  void glMapGrid2f(
    int un,
    double u1,
    double u2,
    int vn,
    double v1,
    double v2,
  ) {
    return _glMapGrid2f(
      un,
      u1,
      u2,
      vn,
      v1,
      v2,
    );
  }

  late final _glMapGrid2fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLfloat, GLfloat, GLint, GLfloat,
              GLfloat)>>('glMapGrid2f');
  late final _glMapGrid2f = _glMapGrid2fPtr
      .asFunction<void Function(int, double, double, int, double, double)>();

  void glMaterialf(
    int face,
    int pname,
    double param,
  ) {
    return _glMaterialf(
      face,
      pname,
      param,
    );
  }

  late final _glMaterialfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLfloat)>>(
          'glMaterialf');
  late final _glMaterialf =
      _glMaterialfPtr.asFunction<void Function(int, int, double)>();

  void glMaterialfv(
    int face,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glMaterialfv(
      face,
      pname,
      params,
    );
  }

  late final _glMaterialfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glMaterialfv');
  late final _glMaterialfv = _glMaterialfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glMateriali(
    int face,
    int pname,
    int param,
  ) {
    return _glMateriali(
      face,
      pname,
      param,
    );
  }

  late final _glMaterialiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLint)>>(
          'glMateriali');
  late final _glMateriali =
      _glMaterialiPtr.asFunction<void Function(int, int, int)>();

  void glMaterialiv(
    int face,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glMaterialiv(
      face,
      pname,
      params,
    );
  }

  late final _glMaterialivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glMaterialiv');
  late final _glMaterialiv = _glMaterialivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glMatrixMode(
    int mode,
  ) {
    return _glMatrixMode(
      mode,
    );
  }

  late final _glMatrixModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glMatrixMode');
  late final _glMatrixMode = _glMatrixModePtr.asFunction<void Function(int)>();

  void glMultMatrixd(
    ffi.Pointer<GLdouble> m,
  ) {
    return _glMultMatrixd(
      m,
    );
  }

  late final _glMultMatrixdPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glMultMatrixd');
  late final _glMultMatrixd =
      _glMultMatrixdPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glMultMatrixf(
    ffi.Pointer<GLfloat> m,
  ) {
    return _glMultMatrixf(
      m,
    );
  }

  late final _glMultMatrixfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glMultMatrixf');
  late final _glMultMatrixf =
      _glMultMatrixfPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glNewList(
    int list,
    int mode,
  ) {
    return _glNewList(
      list,
      mode,
    );
  }

  late final _glNewListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint, GLenum)>>(
          'glNewList');
  late final _glNewList = _glNewListPtr.asFunction<void Function(int, int)>();

  void glNormal3b(
    int nx,
    int ny,
    int nz,
  ) {
    return _glNormal3b(
      nx,
      ny,
      nz,
    );
  }

  late final _glNormal3bPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLbyte, GLbyte, GLbyte)>>(
          'glNormal3b');
  late final _glNormal3b =
      _glNormal3bPtr.asFunction<void Function(int, int, int)>();

  void glNormal3bv(
    ffi.Pointer<GLbyte> v,
  ) {
    return _glNormal3bv(
      v,
    );
  }

  late final _glNormal3bvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLbyte>)>>(
          'glNormal3bv');
  late final _glNormal3bv =
      _glNormal3bvPtr.asFunction<void Function(ffi.Pointer<GLbyte>)>();

  void glNormal3d(
    double nx,
    double ny,
    double nz,
  ) {
    return _glNormal3d(
      nx,
      ny,
      nz,
    );
  }

  late final _glNormal3dPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glNormal3d');
  late final _glNormal3d =
      _glNormal3dPtr.asFunction<void Function(double, double, double)>();

  void glNormal3dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glNormal3dv(
      v,
    );
  }

  late final _glNormal3dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glNormal3dv');
  late final _glNormal3dv =
      _glNormal3dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glNormal3f(
    double nx,
    double ny,
    double nz,
  ) {
    return _glNormal3f(
      nx,
      ny,
      nz,
    );
  }

  late final _glNormal3fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glNormal3f');
  late final _glNormal3f =
      _glNormal3fPtr.asFunction<void Function(double, double, double)>();

  void glNormal3fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glNormal3fv(
      v,
    );
  }

  late final _glNormal3fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glNormal3fv');
  late final _glNormal3fv =
      _glNormal3fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glNormal3i(
    int nx,
    int ny,
    int nz,
  ) {
    return _glNormal3i(
      nx,
      ny,
      nz,
    );
  }

  late final _glNormal3iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint)>>(
          'glNormal3i');
  late final _glNormal3i =
      _glNormal3iPtr.asFunction<void Function(int, int, int)>();

  void glNormal3iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glNormal3iv(
      v,
    );
  }

  late final _glNormal3ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glNormal3iv');
  late final _glNormal3iv =
      _glNormal3ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glNormal3s(
    int nx,
    int ny,
    int nz,
  ) {
    return _glNormal3s(
      nx,
      ny,
      nz,
    );
  }

  late final _glNormal3sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort, GLshort)>>(
          'glNormal3s');
  late final _glNormal3s =
      _glNormal3sPtr.asFunction<void Function(int, int, int)>();

  void glNormal3sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glNormal3sv(
      v,
    );
  }

  late final _glNormal3svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glNormal3sv');
  late final _glNormal3sv =
      _glNormal3svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glNormalPointer(
    int type,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glNormalPointer(
      type,
      stride,
      pointer,
    );
  }

  late final _glNormalPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLvoid>)>>('glNormalPointer');
  late final _glNormalPointer = _glNormalPointerPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLvoid>)>();

  void glOrtho(
    double left,
    double right,
    double bottom,
    double top,
    double zNear,
    double zFar,
  ) {
    return _glOrtho(
      left,
      right,
      bottom,
      top,
      zNear,
      zFar,
    );
  }

  late final _glOrthoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble,
              GLdouble)>>('glOrtho');
  late final _glOrtho = _glOrthoPtr.asFunction<
      void Function(double, double, double, double, double, double)>();

  void glPassThrough(
    double token,
  ) {
    return _glPassThrough(
      token,
    );
  }

  late final _glPassThroughPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glPassThrough');
  late final _glPassThrough =
      _glPassThroughPtr.asFunction<void Function(double)>();

  void glPixelMapfv(
    int map,
    int mapsize,
    ffi.Pointer<GLfloat> values,
  ) {
    return _glPixelMapfv(
      map,
      mapsize,
      values,
    );
  }

  late final _glPixelMapfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLfloat>)>>('glPixelMapfv');
  late final _glPixelMapfv = _glPixelMapfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glPixelMapuiv(
    int map,
    int mapsize,
    ffi.Pointer<GLuint> values,
  ) {
    return _glPixelMapuiv(
      map,
      mapsize,
      values,
    );
  }

  late final _glPixelMapuivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLuint>)>>('glPixelMapuiv');
  late final _glPixelMapuiv = _glPixelMapuivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLuint>)>();

  void glPixelMapusv(
    int map,
    int mapsize,
    ffi.Pointer<GLushort> values,
  ) {
    return _glPixelMapusv(
      map,
      mapsize,
      values,
    );
  }

  late final _glPixelMapusvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLsizei, ffi.Pointer<GLushort>)>>('glPixelMapusv');
  late final _glPixelMapusv = _glPixelMapusvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLushort>)>();

  void glPixelStoref(
    int pname,
    double param,
  ) {
    return _glPixelStoref(
      pname,
      param,
    );
  }

  late final _glPixelStorefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLfloat)>>(
          'glPixelStoref');
  late final _glPixelStoref =
      _glPixelStorefPtr.asFunction<void Function(int, double)>();

  void glPixelStorei(
    int pname,
    int param,
  ) {
    return _glPixelStorei(
      pname,
      param,
    );
  }

  late final _glPixelStoreiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint)>>(
          'glPixelStorei');
  late final _glPixelStorei =
      _glPixelStoreiPtr.asFunction<void Function(int, int)>();

  void glPixelTransferf(
    int pname,
    double param,
  ) {
    return _glPixelTransferf(
      pname,
      param,
    );
  }

  late final _glPixelTransferfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLfloat)>>(
          'glPixelTransferf');
  late final _glPixelTransferf =
      _glPixelTransferfPtr.asFunction<void Function(int, double)>();

  void glPixelTransferi(
    int pname,
    int param,
  ) {
    return _glPixelTransferi(
      pname,
      param,
    );
  }

  late final _glPixelTransferiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint)>>(
          'glPixelTransferi');
  late final _glPixelTransferi =
      _glPixelTransferiPtr.asFunction<void Function(int, int)>();

  void glPixelZoom(
    double xfactor,
    double yfactor,
  ) {
    return _glPixelZoom(
      xfactor,
      yfactor,
    );
  }

  late final _glPixelZoomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glPixelZoom');
  late final _glPixelZoom =
      _glPixelZoomPtr.asFunction<void Function(double, double)>();

  void glPointSize(
    double size,
  ) {
    return _glPointSize(
      size,
    );
  }

  late final _glPointSizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glPointSize');
  late final _glPointSize = _glPointSizePtr.asFunction<void Function(double)>();

  void glPolygonMode(
    int face,
    int mode,
  ) {
    return _glPolygonMode(
      face,
      mode,
    );
  }

  late final _glPolygonModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum)>>(
          'glPolygonMode');
  late final _glPolygonMode =
      _glPolygonModePtr.asFunction<void Function(int, int)>();

  void glPolygonOffset(
    double factor,
    double units,
  ) {
    return _glPolygonOffset(
      factor,
      units,
    );
  }

  late final _glPolygonOffsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glPolygonOffset');
  late final _glPolygonOffset =
      _glPolygonOffsetPtr.asFunction<void Function(double, double)>();

  void glPolygonStipple(
    ffi.Pointer<GLubyte> mask,
  ) {
    return _glPolygonStipple(
      mask,
    );
  }

  late final _glPolygonStipplePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLubyte>)>>(
          'glPolygonStipple');
  late final _glPolygonStipple =
      _glPolygonStipplePtr.asFunction<void Function(ffi.Pointer<GLubyte>)>();

  void glPopAttrib() {
    return _glPopAttrib();
  }

  late final _glPopAttribPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glPopAttrib');
  late final _glPopAttrib = _glPopAttribPtr.asFunction<void Function()>();

  void glPopClientAttrib() {
    return _glPopClientAttrib();
  }

  late final _glPopClientAttribPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glPopClientAttrib');
  late final _glPopClientAttrib =
      _glPopClientAttribPtr.asFunction<void Function()>();

  void glPopMatrix() {
    return _glPopMatrix();
  }

  late final _glPopMatrixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glPopMatrix');
  late final _glPopMatrix = _glPopMatrixPtr.asFunction<void Function()>();

  void glPopName() {
    return _glPopName();
  }

  late final _glPopNamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glPopName');
  late final _glPopName = _glPopNamePtr.asFunction<void Function()>();

  void glPrioritizeTextures(
    int n,
    ffi.Pointer<GLuint> textures,
    ffi.Pointer<GLclampf> priorities,
  ) {
    return _glPrioritizeTextures(
      n,
      textures,
      priorities,
    );
  }

  late final _glPrioritizeTexturesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLsizei, ffi.Pointer<GLuint>,
              ffi.Pointer<GLclampf>)>>('glPrioritizeTextures');
  late final _glPrioritizeTextures = _glPrioritizeTexturesPtr.asFunction<
      void Function(int, ffi.Pointer<GLuint>, ffi.Pointer<GLclampf>)>();

  void glPushAttrib(
    int mask,
  ) {
    return _glPushAttrib(
      mask,
    );
  }

  late final _glPushAttribPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLbitfield)>>(
          'glPushAttrib');
  late final _glPushAttrib = _glPushAttribPtr.asFunction<void Function(int)>();

  void glPushClientAttrib(
    int mask,
  ) {
    return _glPushClientAttrib(
      mask,
    );
  }

  late final _glPushClientAttribPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLbitfield)>>(
          'glPushClientAttrib');
  late final _glPushClientAttrib =
      _glPushClientAttribPtr.asFunction<void Function(int)>();

  void glPushMatrix() {
    return _glPushMatrix();
  }

  late final _glPushMatrixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glPushMatrix');
  late final _glPushMatrix = _glPushMatrixPtr.asFunction<void Function()>();

  void glPushName(
    int name,
  ) {
    return _glPushName(
      name,
    );
  }

  late final _glPushNamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glPushName');
  late final _glPushName = _glPushNamePtr.asFunction<void Function(int)>();

  void glRasterPos2d(
    double x,
    double y,
  ) {
    return _glRasterPos2d(
      x,
      y,
    );
  }

  late final _glRasterPos2dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble)>>(
          'glRasterPos2d');
  late final _glRasterPos2d =
      _glRasterPos2dPtr.asFunction<void Function(double, double)>();

  void glRasterPos2dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glRasterPos2dv(
      v,
    );
  }

  late final _glRasterPos2dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glRasterPos2dv');
  late final _glRasterPos2dv =
      _glRasterPos2dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glRasterPos2f(
    double x,
    double y,
  ) {
    return _glRasterPos2f(
      x,
      y,
    );
  }

  late final _glRasterPos2fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glRasterPos2f');
  late final _glRasterPos2f =
      _glRasterPos2fPtr.asFunction<void Function(double, double)>();

  void glRasterPos2fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glRasterPos2fv(
      v,
    );
  }

  late final _glRasterPos2fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glRasterPos2fv');
  late final _glRasterPos2fv =
      _glRasterPos2fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glRasterPos2i(
    int x,
    int y,
  ) {
    return _glRasterPos2i(
      x,
      y,
    );
  }

  late final _glRasterPos2iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint)>>(
          'glRasterPos2i');
  late final _glRasterPos2i =
      _glRasterPos2iPtr.asFunction<void Function(int, int)>();

  void glRasterPos2iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glRasterPos2iv(
      v,
    );
  }

  late final _glRasterPos2ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glRasterPos2iv');
  late final _glRasterPos2iv =
      _glRasterPos2ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glRasterPos2s(
    int x,
    int y,
  ) {
    return _glRasterPos2s(
      x,
      y,
    );
  }

  late final _glRasterPos2sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort)>>(
          'glRasterPos2s');
  late final _glRasterPos2s =
      _glRasterPos2sPtr.asFunction<void Function(int, int)>();

  void glRasterPos2sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glRasterPos2sv(
      v,
    );
  }

  late final _glRasterPos2svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glRasterPos2sv');
  late final _glRasterPos2sv =
      _glRasterPos2svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glRasterPos3d(
    double x,
    double y,
    double z,
  ) {
    return _glRasterPos3d(
      x,
      y,
      z,
    );
  }

  late final _glRasterPos3dPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glRasterPos3d');
  late final _glRasterPos3d =
      _glRasterPos3dPtr.asFunction<void Function(double, double, double)>();

  void glRasterPos3dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glRasterPos3dv(
      v,
    );
  }

  late final _glRasterPos3dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glRasterPos3dv');
  late final _glRasterPos3dv =
      _glRasterPos3dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glRasterPos3f(
    double x,
    double y,
    double z,
  ) {
    return _glRasterPos3f(
      x,
      y,
      z,
    );
  }

  late final _glRasterPos3fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glRasterPos3f');
  late final _glRasterPos3f =
      _glRasterPos3fPtr.asFunction<void Function(double, double, double)>();

  void glRasterPos3fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glRasterPos3fv(
      v,
    );
  }

  late final _glRasterPos3fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glRasterPos3fv');
  late final _glRasterPos3fv =
      _glRasterPos3fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glRasterPos3i(
    int x,
    int y,
    int z,
  ) {
    return _glRasterPos3i(
      x,
      y,
      z,
    );
  }

  late final _glRasterPos3iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint)>>(
          'glRasterPos3i');
  late final _glRasterPos3i =
      _glRasterPos3iPtr.asFunction<void Function(int, int, int)>();

  void glRasterPos3iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glRasterPos3iv(
      v,
    );
  }

  late final _glRasterPos3ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glRasterPos3iv');
  late final _glRasterPos3iv =
      _glRasterPos3ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glRasterPos3s(
    int x,
    int y,
    int z,
  ) {
    return _glRasterPos3s(
      x,
      y,
      z,
    );
  }

  late final _glRasterPos3sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort, GLshort)>>(
          'glRasterPos3s');
  late final _glRasterPos3s =
      _glRasterPos3sPtr.asFunction<void Function(int, int, int)>();

  void glRasterPos3sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glRasterPos3sv(
      v,
    );
  }

  late final _glRasterPos3svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glRasterPos3sv');
  late final _glRasterPos3sv =
      _glRasterPos3svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glRasterPos4d(
    double x,
    double y,
    double z,
    double w,
  ) {
    return _glRasterPos4d(
      x,
      y,
      z,
      w,
    );
  }

  late final _glRasterPos4dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glRasterPos4d');
  late final _glRasterPos4d = _glRasterPos4dPtr
      .asFunction<void Function(double, double, double, double)>();

  void glRasterPos4dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glRasterPos4dv(
      v,
    );
  }

  late final _glRasterPos4dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glRasterPos4dv');
  late final _glRasterPos4dv =
      _glRasterPos4dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glRasterPos4f(
    double x,
    double y,
    double z,
    double w,
  ) {
    return _glRasterPos4f(
      x,
      y,
      z,
      w,
    );
  }

  late final _glRasterPos4fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLfloat, GLfloat, GLfloat, GLfloat)>>('glRasterPos4f');
  late final _glRasterPos4f = _glRasterPos4fPtr
      .asFunction<void Function(double, double, double, double)>();

  void glRasterPos4fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glRasterPos4fv(
      v,
    );
  }

  late final _glRasterPos4fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glRasterPos4fv');
  late final _glRasterPos4fv =
      _glRasterPos4fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glRasterPos4i(
    int x,
    int y,
    int z,
    int w,
  ) {
    return _glRasterPos4i(
      x,
      y,
      z,
      w,
    );
  }

  late final _glRasterPos4iPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint, GLint)>>(
      'glRasterPos4i');
  late final _glRasterPos4i =
      _glRasterPos4iPtr.asFunction<void Function(int, int, int, int)>();

  void glRasterPos4iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glRasterPos4iv(
      v,
    );
  }

  late final _glRasterPos4ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glRasterPos4iv');
  late final _glRasterPos4iv =
      _glRasterPos4ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glRasterPos4s(
    int x,
    int y,
    int z,
    int w,
  ) {
    return _glRasterPos4s(
      x,
      y,
      z,
      w,
    );
  }

  late final _glRasterPos4sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLshort, GLshort, GLshort, GLshort)>>('glRasterPos4s');
  late final _glRasterPos4s =
      _glRasterPos4sPtr.asFunction<void Function(int, int, int, int)>();

  void glRasterPos4sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glRasterPos4sv(
      v,
    );
  }

  late final _glRasterPos4svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glRasterPos4sv');
  late final _glRasterPos4sv =
      _glRasterPos4svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glReadBuffer(
    int mode,
  ) {
    return _glReadBuffer(
      mode,
    );
  }

  late final _glReadBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glReadBuffer');
  late final _glReadBuffer = _glReadBufferPtr.asFunction<void Function(int)>();

  void glReadPixels(
    int x,
    int y,
    int width,
    int height,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glReadPixels(
      x,
      y,
      width,
      height,
      format,
      type,
      pixels,
    );
  }

  late final _glReadPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum,
              ffi.Pointer<GLvoid>)>>('glReadPixels');
  late final _glReadPixels = _glReadPixelsPtr.asFunction<
      void Function(int, int, int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glRectd(
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _glRectd(
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _glRectdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glRectd');
  late final _glRectd =
      _glRectdPtr.asFunction<void Function(double, double, double, double)>();

  void glRectdv(
    ffi.Pointer<GLdouble> v1,
    ffi.Pointer<GLdouble> v2,
  ) {
    return _glRectdv(
      v1,
      v2,
    );
  }

  late final _glRectdvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLdouble>, ffi.Pointer<GLdouble>)>>('glRectdv');
  late final _glRectdv = _glRectdvPtr.asFunction<
      void Function(ffi.Pointer<GLdouble>, ffi.Pointer<GLdouble>)>();

  void glRectf(
    double x1,
    double y1,
    double x2,
    double y2,
  ) {
    return _glRectf(
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _glRectfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLfloat, GLfloat, GLfloat, GLfloat)>>('glRectf');
  late final _glRectf =
      _glRectfPtr.asFunction<void Function(double, double, double, double)>();

  void glRectfv(
    ffi.Pointer<GLfloat> v1,
    ffi.Pointer<GLfloat> v2,
  ) {
    return _glRectfv(
      v1,
      v2,
    );
  }

  late final _glRectfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLfloat>, ffi.Pointer<GLfloat>)>>('glRectfv');
  late final _glRectfv = _glRectfvPtr
      .asFunction<void Function(ffi.Pointer<GLfloat>, ffi.Pointer<GLfloat>)>();

  void glRecti(
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _glRecti(
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _glRectiPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint, GLint)>>(
      'glRecti');
  late final _glRecti =
      _glRectiPtr.asFunction<void Function(int, int, int, int)>();

  void glRectiv(
    ffi.Pointer<GLint> v1,
    ffi.Pointer<GLint> v2,
  ) {
    return _glRectiv(
      v1,
      v2,
    );
  }

  late final _glRectivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLint>, ffi.Pointer<GLint>)>>('glRectiv');
  late final _glRectiv = _glRectivPtr
      .asFunction<void Function(ffi.Pointer<GLint>, ffi.Pointer<GLint>)>();

  void glRects(
    int x1,
    int y1,
    int x2,
    int y2,
  ) {
    return _glRects(
      x1,
      y1,
      x2,
      y2,
    );
  }

  late final _glRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLshort, GLshort, GLshort, GLshort)>>('glRects');
  late final _glRects =
      _glRectsPtr.asFunction<void Function(int, int, int, int)>();

  void glRectsv(
    ffi.Pointer<GLshort> v1,
    ffi.Pointer<GLshort> v2,
  ) {
    return _glRectsv(
      v1,
      v2,
    );
  }

  late final _glRectsvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLshort>, ffi.Pointer<GLshort>)>>('glRectsv');
  late final _glRectsv = _glRectsvPtr
      .asFunction<void Function(ffi.Pointer<GLshort>, ffi.Pointer<GLshort>)>();

  int glRenderMode(
    int mode,
  ) {
    return _glRenderMode(
      mode,
    );
  }

  late final _glRenderModePtr =
      _lookup<ffi.NativeFunction<GLint Function(GLenum)>>('glRenderMode');
  late final _glRenderMode = _glRenderModePtr.asFunction<int Function(int)>();

  void glRotated(
    double angle,
    double x,
    double y,
    double z,
  ) {
    return _glRotated(
      angle,
      x,
      y,
      z,
    );
  }

  late final _glRotatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glRotated');
  late final _glRotated =
      _glRotatedPtr.asFunction<void Function(double, double, double, double)>();

  void glRotatef(
    double angle,
    double x,
    double y,
    double z,
  ) {
    return _glRotatef(
      angle,
      x,
      y,
      z,
    );
  }

  late final _glRotatefPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLfloat, GLfloat, GLfloat, GLfloat)>>('glRotatef');
  late final _glRotatef =
      _glRotatefPtr.asFunction<void Function(double, double, double, double)>();

  void glScaled(
    double x,
    double y,
    double z,
  ) {
    return _glScaled(
      x,
      y,
      z,
    );
  }

  late final _glScaledPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glScaled');
  late final _glScaled =
      _glScaledPtr.asFunction<void Function(double, double, double)>();

  void glScalef(
    double x,
    double y,
    double z,
  ) {
    return _glScalef(
      x,
      y,
      z,
    );
  }

  late final _glScalefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glScalef');
  late final _glScalef =
      _glScalefPtr.asFunction<void Function(double, double, double)>();

  void glScissor(
    int x,
    int y,
    int width,
    int height,
  ) {
    return _glScissor(
      x,
      y,
      width,
      height,
    );
  }

  late final _glScissorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLint, GLsizei, GLsizei)>>('glScissor');
  late final _glScissor =
      _glScissorPtr.asFunction<void Function(int, int, int, int)>();

  void glSelectBuffer(
    int size,
    ffi.Pointer<GLuint> buffer,
  ) {
    return _glSelectBuffer(
      size,
      buffer,
    );
  }

  late final _glSelectBufferPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLsizei, ffi.Pointer<GLuint>)>>(
      'glSelectBuffer');
  late final _glSelectBuffer =
      _glSelectBufferPtr.asFunction<void Function(int, ffi.Pointer<GLuint>)>();

  void glShadeModel(
    int mode,
  ) {
    return _glShadeModel(
      mode,
    );
  }

  late final _glShadeModelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum)>>('glShadeModel');
  late final _glShadeModel = _glShadeModelPtr.asFunction<void Function(int)>();

  void glStencilFunc(
    int func,
    int ref,
    int mask,
  ) {
    return _glStencilFunc(
      func,
      ref,
      mask,
    );
  }

  late final _glStencilFuncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLint, GLuint)>>(
          'glStencilFunc');
  late final _glStencilFunc =
      _glStencilFuncPtr.asFunction<void Function(int, int, int)>();

  void glStencilMask(
    int mask,
  ) {
    return _glStencilMask(
      mask,
    );
  }

  late final _glStencilMaskPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLuint)>>('glStencilMask');
  late final _glStencilMask =
      _glStencilMaskPtr.asFunction<void Function(int)>();

  void glStencilOp(
    int fail,
    int zfail,
    int zpass,
  ) {
    return _glStencilOp(
      fail,
      zfail,
      zpass,
    );
  }

  late final _glStencilOpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLenum)>>(
          'glStencilOp');
  late final _glStencilOp =
      _glStencilOpPtr.asFunction<void Function(int, int, int)>();

  void glTexCoord1d(
    double s,
  ) {
    return _glTexCoord1d(
      s,
    );
  }

  late final _glTexCoord1dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble)>>('glTexCoord1d');
  late final _glTexCoord1d =
      _glTexCoord1dPtr.asFunction<void Function(double)>();

  void glTexCoord1dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glTexCoord1dv(
      v,
    );
  }

  late final _glTexCoord1dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glTexCoord1dv');
  late final _glTexCoord1dv =
      _glTexCoord1dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glTexCoord1f(
    double s,
  ) {
    return _glTexCoord1f(
      s,
    );
  }

  late final _glTexCoord1fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat)>>('glTexCoord1f');
  late final _glTexCoord1f =
      _glTexCoord1fPtr.asFunction<void Function(double)>();

  void glTexCoord1fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glTexCoord1fv(
      v,
    );
  }

  late final _glTexCoord1fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glTexCoord1fv');
  late final _glTexCoord1fv =
      _glTexCoord1fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glTexCoord1i(
    int s,
  ) {
    return _glTexCoord1i(
      s,
    );
  }

  late final _glTexCoord1iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint)>>('glTexCoord1i');
  late final _glTexCoord1i = _glTexCoord1iPtr.asFunction<void Function(int)>();

  void glTexCoord1iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glTexCoord1iv(
      v,
    );
  }

  late final _glTexCoord1ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glTexCoord1iv');
  late final _glTexCoord1iv =
      _glTexCoord1ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glTexCoord1s(
    int s,
  ) {
    return _glTexCoord1s(
      s,
    );
  }

  late final _glTexCoord1sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort)>>('glTexCoord1s');
  late final _glTexCoord1s = _glTexCoord1sPtr.asFunction<void Function(int)>();

  void glTexCoord1sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glTexCoord1sv(
      v,
    );
  }

  late final _glTexCoord1svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glTexCoord1sv');
  late final _glTexCoord1sv =
      _glTexCoord1svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glTexCoord2d(
    double s,
    double t,
  ) {
    return _glTexCoord2d(
      s,
      t,
    );
  }

  late final _glTexCoord2dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble)>>(
          'glTexCoord2d');
  late final _glTexCoord2d =
      _glTexCoord2dPtr.asFunction<void Function(double, double)>();

  void glTexCoord2dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glTexCoord2dv(
      v,
    );
  }

  late final _glTexCoord2dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glTexCoord2dv');
  late final _glTexCoord2dv =
      _glTexCoord2dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glTexCoord2f(
    double s,
    double t,
  ) {
    return _glTexCoord2f(
      s,
      t,
    );
  }

  late final _glTexCoord2fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glTexCoord2f');
  late final _glTexCoord2f =
      _glTexCoord2fPtr.asFunction<void Function(double, double)>();

  void glTexCoord2fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glTexCoord2fv(
      v,
    );
  }

  late final _glTexCoord2fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glTexCoord2fv');
  late final _glTexCoord2fv =
      _glTexCoord2fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glTexCoord2i(
    int s,
    int t,
  ) {
    return _glTexCoord2i(
      s,
      t,
    );
  }

  late final _glTexCoord2iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint)>>(
          'glTexCoord2i');
  late final _glTexCoord2i =
      _glTexCoord2iPtr.asFunction<void Function(int, int)>();

  void glTexCoord2iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glTexCoord2iv(
      v,
    );
  }

  late final _glTexCoord2ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glTexCoord2iv');
  late final _glTexCoord2iv =
      _glTexCoord2ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glTexCoord2s(
    int s,
    int t,
  ) {
    return _glTexCoord2s(
      s,
      t,
    );
  }

  late final _glTexCoord2sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort)>>(
          'glTexCoord2s');
  late final _glTexCoord2s =
      _glTexCoord2sPtr.asFunction<void Function(int, int)>();

  void glTexCoord2sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glTexCoord2sv(
      v,
    );
  }

  late final _glTexCoord2svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glTexCoord2sv');
  late final _glTexCoord2sv =
      _glTexCoord2svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glTexCoord3d(
    double s,
    double t,
    double r,
  ) {
    return _glTexCoord3d(
      s,
      t,
      r,
    );
  }

  late final _glTexCoord3dPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glTexCoord3d');
  late final _glTexCoord3d =
      _glTexCoord3dPtr.asFunction<void Function(double, double, double)>();

  void glTexCoord3dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glTexCoord3dv(
      v,
    );
  }

  late final _glTexCoord3dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glTexCoord3dv');
  late final _glTexCoord3dv =
      _glTexCoord3dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glTexCoord3f(
    double s,
    double t,
    double r,
  ) {
    return _glTexCoord3f(
      s,
      t,
      r,
    );
  }

  late final _glTexCoord3fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glTexCoord3f');
  late final _glTexCoord3f =
      _glTexCoord3fPtr.asFunction<void Function(double, double, double)>();

  void glTexCoord3fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glTexCoord3fv(
      v,
    );
  }

  late final _glTexCoord3fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glTexCoord3fv');
  late final _glTexCoord3fv =
      _glTexCoord3fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glTexCoord3i(
    int s,
    int t,
    int r,
  ) {
    return _glTexCoord3i(
      s,
      t,
      r,
    );
  }

  late final _glTexCoord3iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint)>>(
          'glTexCoord3i');
  late final _glTexCoord3i =
      _glTexCoord3iPtr.asFunction<void Function(int, int, int)>();

  void glTexCoord3iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glTexCoord3iv(
      v,
    );
  }

  late final _glTexCoord3ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glTexCoord3iv');
  late final _glTexCoord3iv =
      _glTexCoord3ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glTexCoord3s(
    int s,
    int t,
    int r,
  ) {
    return _glTexCoord3s(
      s,
      t,
      r,
    );
  }

  late final _glTexCoord3sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort, GLshort)>>(
          'glTexCoord3s');
  late final _glTexCoord3s =
      _glTexCoord3sPtr.asFunction<void Function(int, int, int)>();

  void glTexCoord3sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glTexCoord3sv(
      v,
    );
  }

  late final _glTexCoord3svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glTexCoord3sv');
  late final _glTexCoord3sv =
      _glTexCoord3svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glTexCoord4d(
    double s,
    double t,
    double r,
    double q,
  ) {
    return _glTexCoord4d(
      s,
      t,
      r,
      q,
    );
  }

  late final _glTexCoord4dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glTexCoord4d');
  late final _glTexCoord4d = _glTexCoord4dPtr
      .asFunction<void Function(double, double, double, double)>();

  void glTexCoord4dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glTexCoord4dv(
      v,
    );
  }

  late final _glTexCoord4dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glTexCoord4dv');
  late final _glTexCoord4dv =
      _glTexCoord4dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glTexCoord4f(
    double s,
    double t,
    double r,
    double q,
  ) {
    return _glTexCoord4f(
      s,
      t,
      r,
      q,
    );
  }

  late final _glTexCoord4fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLfloat, GLfloat, GLfloat, GLfloat)>>('glTexCoord4f');
  late final _glTexCoord4f = _glTexCoord4fPtr
      .asFunction<void Function(double, double, double, double)>();

  void glTexCoord4fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glTexCoord4fv(
      v,
    );
  }

  late final _glTexCoord4fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glTexCoord4fv');
  late final _glTexCoord4fv =
      _glTexCoord4fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glTexCoord4i(
    int s,
    int t,
    int r,
    int q,
  ) {
    return _glTexCoord4i(
      s,
      t,
      r,
      q,
    );
  }

  late final _glTexCoord4iPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint, GLint)>>(
      'glTexCoord4i');
  late final _glTexCoord4i =
      _glTexCoord4iPtr.asFunction<void Function(int, int, int, int)>();

  void glTexCoord4iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glTexCoord4iv(
      v,
    );
  }

  late final _glTexCoord4ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glTexCoord4iv');
  late final _glTexCoord4iv =
      _glTexCoord4ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glTexCoord4s(
    int s,
    int t,
    int r,
    int q,
  ) {
    return _glTexCoord4s(
      s,
      t,
      r,
      q,
    );
  }

  late final _glTexCoord4sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLshort, GLshort, GLshort, GLshort)>>('glTexCoord4s');
  late final _glTexCoord4s =
      _glTexCoord4sPtr.asFunction<void Function(int, int, int, int)>();

  void glTexCoord4sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glTexCoord4sv(
      v,
    );
  }

  late final _glTexCoord4svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glTexCoord4sv');
  late final _glTexCoord4sv =
      _glTexCoord4svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glTexCoordPointer(
    int size,
    int type,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glTexCoordPointer(
      size,
      type,
      stride,
      pointer,
    );
  }

  late final _glTexCoordPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLenum, GLsizei,
              ffi.Pointer<GLvoid>)>>('glTexCoordPointer');
  late final _glTexCoordPointer = _glTexCoordPointerPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLvoid>)>();

  void glTexEnvf(
    int target,
    int pname,
    double param,
  ) {
    return _glTexEnvf(
      target,
      pname,
      param,
    );
  }

  late final _glTexEnvfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLfloat)>>(
          'glTexEnvf');
  late final _glTexEnvf =
      _glTexEnvfPtr.asFunction<void Function(int, int, double)>();

  void glTexEnvfv(
    int target,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glTexEnvfv(
      target,
      pname,
      params,
    );
  }

  late final _glTexEnvfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glTexEnvfv');
  late final _glTexEnvfv = _glTexEnvfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glTexEnvi(
    int target,
    int pname,
    int param,
  ) {
    return _glTexEnvi(
      target,
      pname,
      param,
    );
  }

  late final _glTexEnviPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLint)>>(
          'glTexEnvi');
  late final _glTexEnvi =
      _glTexEnviPtr.asFunction<void Function(int, int, int)>();

  void glTexEnviv(
    int target,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glTexEnviv(
      target,
      pname,
      params,
    );
  }

  late final _glTexEnvivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLenum, ffi.Pointer<GLint>)>>('glTexEnviv');
  late final _glTexEnviv =
      _glTexEnvivPtr.asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glTexGend(
    int coord,
    int pname,
    double param,
  ) {
    return _glTexGend(
      coord,
      pname,
      param,
    );
  }

  late final _glTexGendPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLdouble)>>(
          'glTexGend');
  late final _glTexGend =
      _glTexGendPtr.asFunction<void Function(int, int, double)>();

  void glTexGendv(
    int coord,
    int pname,
    ffi.Pointer<GLdouble> params,
  ) {
    return _glTexGendv(
      coord,
      pname,
      params,
    );
  }

  late final _glTexGendvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLdouble>)>>('glTexGendv');
  late final _glTexGendv = _glTexGendvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLdouble>)>();

  void glTexGenf(
    int coord,
    int pname,
    double param,
  ) {
    return _glTexGenf(
      coord,
      pname,
      param,
    );
  }

  late final _glTexGenfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLfloat)>>(
          'glTexGenf');
  late final _glTexGenf =
      _glTexGenfPtr.asFunction<void Function(int, int, double)>();

  void glTexGenfv(
    int coord,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glTexGenfv(
      coord,
      pname,
      params,
    );
  }

  late final _glTexGenfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glTexGenfv');
  late final _glTexGenfv = _glTexGenfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glTexGeni(
    int coord,
    int pname,
    int param,
  ) {
    return _glTexGeni(
      coord,
      pname,
      param,
    );
  }

  late final _glTexGeniPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLint)>>(
          'glTexGeni');
  late final _glTexGeni =
      _glTexGeniPtr.asFunction<void Function(int, int, int)>();

  void glTexGeniv(
    int coord,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glTexGeniv(
      coord,
      pname,
      params,
    );
  }

  late final _glTexGenivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLenum, ffi.Pointer<GLint>)>>('glTexGeniv');
  late final _glTexGeniv =
      _glTexGenivPtr.asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glTexImage1D(
    int target,
    int level,
    int internalformat,
    int width,
    int border,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glTexImage1D(
      target,
      level,
      internalformat,
      width,
      border,
      format,
      type,
      pixels,
    );
  }

  late final _glTexImage1DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLsizei, GLint, GLenum,
              GLenum, ffi.Pointer<GLvoid>)>>('glTexImage1D');
  late final _glTexImage1D = _glTexImage1DPtr.asFunction<
      void Function(int, int, int, int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glTexImage2D(
    int target,
    int level,
    int internalformat,
    int width,
    int height,
    int border,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glTexImage2D(
      target,
      level,
      internalformat,
      width,
      height,
      border,
      format,
      type,
      pixels,
    );
  }

  late final _glTexImage2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLsizei, GLsizei, GLint,
              GLenum, GLenum, ffi.Pointer<GLvoid>)>>('glTexImage2D');
  late final _glTexImage2D = _glTexImage2DPtr.asFunction<
      void Function(
          int, int, int, int, int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glTexParameterf(
    int target,
    int pname,
    double param,
  ) {
    return _glTexParameterf(
      target,
      pname,
      param,
    );
  }

  late final _glTexParameterfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLfloat)>>(
          'glTexParameterf');
  late final _glTexParameterf =
      _glTexParameterfPtr.asFunction<void Function(int, int, double)>();

  void glTexParameterfv(
    int target,
    int pname,
    ffi.Pointer<GLfloat> params,
  ) {
    return _glTexParameterfv(
      target,
      pname,
      params,
    );
  }

  late final _glTexParameterfvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLfloat>)>>('glTexParameterfv');
  late final _glTexParameterfv = _glTexParameterfvPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLfloat>)>();

  void glTexParameteri(
    int target,
    int pname,
    int param,
  ) {
    return _glTexParameteri(
      target,
      pname,
      param,
    );
  }

  late final _glTexParameteriPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLenum, GLenum, GLint)>>(
          'glTexParameteri');
  late final _glTexParameteri =
      _glTexParameteriPtr.asFunction<void Function(int, int, int)>();

  void glTexParameteriv(
    int target,
    int pname,
    ffi.Pointer<GLint> params,
  ) {
    return _glTexParameteriv(
      target,
      pname,
      params,
    );
  }

  late final _glTexParameterivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLenum, GLenum, ffi.Pointer<GLint>)>>('glTexParameteriv');
  late final _glTexParameteriv = _glTexParameterivPtr
      .asFunction<void Function(int, int, ffi.Pointer<GLint>)>();

  void glTexSubImage1D(
    int target,
    int level,
    int xoffset,
    int width,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glTexSubImage1D(
      target,
      level,
      xoffset,
      width,
      format,
      type,
      pixels,
    );
  }

  late final _glTexSubImage1DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLsizei, GLenum, GLenum,
              ffi.Pointer<GLvoid>)>>('glTexSubImage1D');
  late final _glTexSubImage1D = _glTexSubImage1DPtr.asFunction<
      void Function(int, int, int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glTexSubImage2D(
    int target,
    int level,
    int xoffset,
    int yoffset,
    int width,
    int height,
    int format,
    int type,
    ffi.Pointer<GLvoid> pixels,
  ) {
    return _glTexSubImage2D(
      target,
      level,
      xoffset,
      yoffset,
      width,
      height,
      format,
      type,
      pixels,
    );
  }

  late final _glTexSubImage2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLenum, GLint, GLint, GLint, GLsizei, GLsizei,
              GLenum, GLenum, ffi.Pointer<GLvoid>)>>('glTexSubImage2D');
  late final _glTexSubImage2D = _glTexSubImage2DPtr.asFunction<
      void Function(
          int, int, int, int, int, int, int, int, ffi.Pointer<GLvoid>)>();

  void glTranslated(
    double x,
    double y,
    double z,
  ) {
    return _glTranslated(
      x,
      y,
      z,
    );
  }

  late final _glTranslatedPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glTranslated');
  late final _glTranslated =
      _glTranslatedPtr.asFunction<void Function(double, double, double)>();

  void glTranslatef(
    double x,
    double y,
    double z,
  ) {
    return _glTranslatef(
      x,
      y,
      z,
    );
  }

  late final _glTranslatefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glTranslatef');
  late final _glTranslatef =
      _glTranslatefPtr.asFunction<void Function(double, double, double)>();

  void glVertex2d(
    double x,
    double y,
  ) {
    return _glVertex2d(
      x,
      y,
    );
  }

  late final _glVertex2dPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble)>>(
          'glVertex2d');
  late final _glVertex2d =
      _glVertex2dPtr.asFunction<void Function(double, double)>();

  void glVertex2dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glVertex2dv(
      v,
    );
  }

  late final _glVertex2dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glVertex2dv');
  late final _glVertex2dv =
      _glVertex2dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glVertex2f(
    double x,
    double y,
  ) {
    return _glVertex2f(
      x,
      y,
    );
  }

  late final _glVertex2fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat)>>(
          'glVertex2f');
  late final _glVertex2f =
      _glVertex2fPtr.asFunction<void Function(double, double)>();

  void glVertex2fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glVertex2fv(
      v,
    );
  }

  late final _glVertex2fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glVertex2fv');
  late final _glVertex2fv =
      _glVertex2fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glVertex2i(
    int x,
    int y,
  ) {
    return _glVertex2i(
      x,
      y,
    );
  }

  late final _glVertex2iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint)>>(
          'glVertex2i');
  late final _glVertex2i = _glVertex2iPtr.asFunction<void Function(int, int)>();

  void glVertex2iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glVertex2iv(
      v,
    );
  }

  late final _glVertex2ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glVertex2iv');
  late final _glVertex2iv =
      _glVertex2ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glVertex2s(
    int x,
    int y,
  ) {
    return _glVertex2s(
      x,
      y,
    );
  }

  late final _glVertex2sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort)>>(
          'glVertex2s');
  late final _glVertex2s = _glVertex2sPtr.asFunction<void Function(int, int)>();

  void glVertex2sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glVertex2sv(
      v,
    );
  }

  late final _glVertex2svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glVertex2sv');
  late final _glVertex2sv =
      _glVertex2svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glVertex3d(
    double x,
    double y,
    double z,
  ) {
    return _glVertex3d(
      x,
      y,
      z,
    );
  }

  late final _glVertex3dPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLdouble, GLdouble, GLdouble)>>(
      'glVertex3d');
  late final _glVertex3d =
      _glVertex3dPtr.asFunction<void Function(double, double, double)>();

  void glVertex3dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glVertex3dv(
      v,
    );
  }

  late final _glVertex3dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glVertex3dv');
  late final _glVertex3dv =
      _glVertex3dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glVertex3f(
    double x,
    double y,
    double z,
  ) {
    return _glVertex3f(
      x,
      y,
      z,
    );
  }

  late final _glVertex3fPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLfloat, GLfloat, GLfloat)>>(
          'glVertex3f');
  late final _glVertex3f =
      _glVertex3fPtr.asFunction<void Function(double, double, double)>();

  void glVertex3fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glVertex3fv(
      v,
    );
  }

  late final _glVertex3fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glVertex3fv');
  late final _glVertex3fv =
      _glVertex3fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glVertex3i(
    int x,
    int y,
    int z,
  ) {
    return _glVertex3i(
      x,
      y,
      z,
    );
  }

  late final _glVertex3iPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint)>>(
          'glVertex3i');
  late final _glVertex3i =
      _glVertex3iPtr.asFunction<void Function(int, int, int)>();

  void glVertex3iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glVertex3iv(
      v,
    );
  }

  late final _glVertex3ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glVertex3iv');
  late final _glVertex3iv =
      _glVertex3ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glVertex3s(
    int x,
    int y,
    int z,
  ) {
    return _glVertex3s(
      x,
      y,
      z,
    );
  }

  late final _glVertex3sPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(GLshort, GLshort, GLshort)>>(
          'glVertex3s');
  late final _glVertex3s =
      _glVertex3sPtr.asFunction<void Function(int, int, int)>();

  void glVertex3sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glVertex3sv(
      v,
    );
  }

  late final _glVertex3svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glVertex3sv');
  late final _glVertex3sv =
      _glVertex3svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glVertex4d(
    double x,
    double y,
    double z,
    double w,
  ) {
    return _glVertex4d(
      x,
      y,
      z,
      w,
    );
  }

  late final _glVertex4dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLdouble, GLdouble, GLdouble, GLdouble)>>('glVertex4d');
  late final _glVertex4d = _glVertex4dPtr
      .asFunction<void Function(double, double, double, double)>();

  void glVertex4dv(
    ffi.Pointer<GLdouble> v,
  ) {
    return _glVertex4dv(
      v,
    );
  }

  late final _glVertex4dvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLdouble>)>>(
          'glVertex4dv');
  late final _glVertex4dv =
      _glVertex4dvPtr.asFunction<void Function(ffi.Pointer<GLdouble>)>();

  void glVertex4f(
    double x,
    double y,
    double z,
    double w,
  ) {
    return _glVertex4f(
      x,
      y,
      z,
      w,
    );
  }

  late final _glVertex4fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLfloat, GLfloat, GLfloat, GLfloat)>>('glVertex4f');
  late final _glVertex4f = _glVertex4fPtr
      .asFunction<void Function(double, double, double, double)>();

  void glVertex4fv(
    ffi.Pointer<GLfloat> v,
  ) {
    return _glVertex4fv(
      v,
    );
  }

  late final _glVertex4fvPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLfloat>)>>(
          'glVertex4fv');
  late final _glVertex4fv =
      _glVertex4fvPtr.asFunction<void Function(ffi.Pointer<GLfloat>)>();

  void glVertex4i(
    int x,
    int y,
    int z,
    int w,
  ) {
    return _glVertex4i(
      x,
      y,
      z,
      w,
    );
  }

  late final _glVertex4iPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(GLint, GLint, GLint, GLint)>>(
      'glVertex4i');
  late final _glVertex4i =
      _glVertex4iPtr.asFunction<void Function(int, int, int, int)>();

  void glVertex4iv(
    ffi.Pointer<GLint> v,
  ) {
    return _glVertex4iv(
      v,
    );
  }

  late final _glVertex4ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLint>)>>(
          'glVertex4iv');
  late final _glVertex4iv =
      _glVertex4ivPtr.asFunction<void Function(ffi.Pointer<GLint>)>();

  void glVertex4s(
    int x,
    int y,
    int z,
    int w,
  ) {
    return _glVertex4s(
      x,
      y,
      z,
      w,
    );
  }

  late final _glVertex4sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLshort, GLshort, GLshort, GLshort)>>('glVertex4s');
  late final _glVertex4s =
      _glVertex4sPtr.asFunction<void Function(int, int, int, int)>();

  void glVertex4sv(
    ffi.Pointer<GLshort> v,
  ) {
    return _glVertex4sv(
      v,
    );
  }

  late final _glVertex4svPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLshort>)>>(
          'glVertex4sv');
  late final _glVertex4sv =
      _glVertex4svPtr.asFunction<void Function(ffi.Pointer<GLshort>)>();

  void glVertexPointer(
    int size,
    int type,
    int stride,
    ffi.Pointer<GLvoid> pointer,
  ) {
    return _glVertexPointer(
      size,
      type,
      stride,
      pointer,
    );
  }

  late final _glVertexPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              GLint, GLenum, GLsizei, ffi.Pointer<GLvoid>)>>('glVertexPointer');
  late final _glVertexPointer = _glVertexPointerPtr
      .asFunction<void Function(int, int, int, ffi.Pointer<GLvoid>)>();

  void glViewport(
    int x,
    int y,
    int width,
    int height,
  ) {
    return _glViewport(
      x,
      y,
      width,
      height,
    );
  }

  late final _glViewportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(GLint, GLint, GLsizei, GLsizei)>>('glViewport');
  late final _glViewport =
      _glViewportPtr.asFunction<void Function(int, int, int, int)>();

  /// ! @brief Initializes the GLFW library.
  ///
  /// This function initializes the GLFW library.  Before most GLFW functions can
  /// be used, GLFW must be initialized, and before an application terminates GLFW
  /// should be terminated in order to free any resources allocated during or
  /// after initialization.
  ///
  /// If this function fails, it calls @ref glfwTerminate before returning.  If it
  /// succeeds, you should call @ref glfwTerminate before the application exits.
  ///
  /// Additional calls to this function after successful initialization but before
  /// termination will return `GLFW_TRUE` immediately.
  ///
  /// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark @macos This function will change the current directory of the
  /// application to the `Contents/Resources` subdirectory of the application's
  /// bundle, if present.  This can be disabled with the @ref
  /// GLFW_COCOA_CHDIR_RESOURCES init hint.
  ///
  /// @remark @x11 This function will set the `LC_CTYPE` category of the
  /// application locale according to the current environment if that category is
  /// still "C".  This is because the "C" locale breaks Unicode text input.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref intro_init
  /// @sa @ref glfwTerminate
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup init
  int glfwInit() {
    return _glfwInit();
  }

  late final _glfwInitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('glfwInit');
  late final _glfwInit = _glfwInitPtr.asFunction<int Function()>();

  /// ! @brief Terminates the GLFW library.
  ///
  /// This function destroys all remaining windows and cursors, restores any
  /// modified gamma ramps and frees any other allocated resources.  Once this
  /// function is called, you must again call @ref glfwInit successfully before
  /// you will be able to use most GLFW functions.
  ///
  /// If GLFW has been successfully initialized, this function should be called
  /// before the application exits.  If initialization fails, there is no need to
  /// call this function, as it is called by @ref glfwInit before it returns
  /// failure.
  ///
  /// This function has no effect if GLFW is not initialized.
  ///
  /// @errors Possible errors include @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark This function may be called before @ref glfwInit.
  ///
  /// @warning The contexts of any remaining windows must not be current on any
  /// other thread when this function is called.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref intro_init
  /// @sa @ref glfwInit
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup init
  void glfwTerminate() {
    return _glfwTerminate();
  }

  late final _glfwTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glfwTerminate');
  late final _glfwTerminate = _glfwTerminatePtr.asFunction<void Function()>();

  /// ! @brief Sets the specified init hint to the desired value.
  ///
  /// This function sets hints for the next initialization of GLFW.
  ///
  /// The values you set hints to are never reset by GLFW, but they only take
  /// effect during initialization.  Once GLFW has been initialized, any values
  /// you set will be ignored until the library is terminated and initialized
  /// again.
  ///
  /// Some hints are platform specific.  These may be set on any platform but they
  /// will only affect their specific platform.  Other platforms will ignore them.
  /// Setting these hints requires no platform specific headers or functions.
  ///
  /// @param[in] hint The [init hint](@ref init_hints) to set.
  /// @param[in] value The new value of the init hint.
  ///
  /// @errors Possible errors include @ref GLFW_INVALID_ENUM and @ref
  /// GLFW_INVALID_VALUE.
  ///
  /// @remarks This function may be called before @ref glfwInit.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa init_hints
  /// @sa glfwInit
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup init
  void glfwInitHint(
    int hint,
    int value,
  ) {
    return _glfwInitHint(
      hint,
      value,
    );
  }

  late final _glfwInitHintPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'glfwInitHint');
  late final _glfwInitHint =
      _glfwInitHintPtr.asFunction<void Function(int, int)>();

  /// ! @brief Retrieves the version of the GLFW library.
  ///
  /// This function retrieves the major, minor and revision numbers of the GLFW
  /// library.  It is intended for when you are using GLFW as a shared library and
  /// want to ensure that you are using the minimum required version.
  ///
  /// Any or all of the version arguments may be `NULL`.
  ///
  /// @param[out] major Where to store the major version number, or `NULL`.
  /// @param[out] minor Where to store the minor version number, or `NULL`.
  /// @param[out] rev Where to store the revision number, or `NULL`.
  ///
  /// @errors None.
  ///
  /// @remark This function may be called before @ref glfwInit.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref intro_version
  /// @sa @ref glfwGetVersionString
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup init
  void glfwGetVersion(
    ffi.Pointer<ffi.Int32> major,
    ffi.Pointer<ffi.Int32> minor,
    ffi.Pointer<ffi.Int32> rev,
  ) {
    return _glfwGetVersion(
      major,
      minor,
      rev,
    );
  }

  late final _glfwGetVersionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetVersion');
  late final _glfwGetVersion = _glfwGetVersionPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns a string describing the compile-time configuration.
  ///
  /// This function returns the compile-time generated
  /// [version string](@ref intro_version_string) of the GLFW library binary.  It
  /// describes the version, platform, compiler and any platform-specific
  /// compile-time options.  It should not be confused with the OpenGL or OpenGL
  /// ES version string, queried with `glGetString`.
  ///
  /// __Do not use the version string__ to parse the GLFW library version.  The
  /// @ref glfwGetVersion function provides the version of the running library
  /// binary in numerical format.
  ///
  /// @return The ASCII encoded GLFW version string.
  ///
  /// @errors None.
  ///
  /// @remark This function may be called before @ref glfwInit.
  ///
  /// @pointer_lifetime The returned string is static and compile-time generated.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref intro_version
  /// @sa @ref glfwGetVersion
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup init
  ffi.Pointer<ffi.Int8> glfwGetVersionString() {
    return _glfwGetVersionString();
  }

  late final _glfwGetVersionStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'glfwGetVersionString');
  late final _glfwGetVersionString =
      _glfwGetVersionStringPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();

  /// ! @brief Returns and clears the last error for the calling thread.
  ///
  /// This function returns and clears the [error code](@ref errors) of the last
  /// error that occurred on the calling thread, and optionally a UTF-8 encoded
  /// human-readable description of it.  If no error has occurred since the last
  /// call, it returns @ref GLFW_NO_ERROR (zero) and the description pointer is
  /// set to `NULL`.
  ///
  /// @param[in] description Where to store the error description pointer, or `NULL`.
  /// @return The last error code for the calling thread, or @ref GLFW_NO_ERROR
  /// (zero).
  ///
  /// @errors None.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is guaranteed to be valid only until the
  /// next error occurs or the library is terminated.
  ///
  /// @remark This function may be called before @ref glfwInit.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref error_handling
  /// @sa @ref glfwSetErrorCallback
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup init
  int glfwGetError(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> description,
  ) {
    return _glfwGetError(
      description,
    );
  }

  late final _glfwGetErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('glfwGetError');
  late final _glfwGetError = _glfwGetErrorPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// ! @brief Sets the error callback.
  ///
  /// This function sets the error callback, which is called with an error code
  /// and a human-readable description each time a GLFW error occurs.
  ///
  /// The error code is set before the callback is called.  Calling @ref
  /// glfwGetError from the error callback will return the same value as the error
  /// code argument.
  ///
  /// The error callback is called on the thread where the error occurred.  If you
  /// are using GLFW from multiple threads, your error callback needs to be
  /// written accordingly.
  ///
  /// Because the description string may have been generated specifically for that
  /// error, it is not guaranteed to be valid after the callback has returned.  If
  /// you wish to use it after the callback returns, you need to make a copy.
  ///
  /// Once set, the error callback remains set even after the library has been
  /// terminated.
  ///
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set.
  ///
  /// @callback_signature
  /// @code
  /// void callback_name(int error_code, const char* description)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [callback pointer type](@ref GLFWerrorfun).
  ///
  /// @errors None.
  ///
  /// @remark This function may be called before @ref glfwInit.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref error_handling
  /// @sa @ref glfwGetError
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup init
  GLFWerrorfun glfwSetErrorCallback(
    GLFWerrorfun callback,
  ) {
    return _glfwSetErrorCallback(
      callback,
    );
  }

  late final _glfwSetErrorCallbackPtr =
      _lookup<ffi.NativeFunction<GLFWerrorfun Function(GLFWerrorfun)>>(
          'glfwSetErrorCallback');
  late final _glfwSetErrorCallback = _glfwSetErrorCallbackPtr
      .asFunction<GLFWerrorfun Function(GLFWerrorfun)>();

  /// ! @brief Returns the currently connected monitors.
  ///
  /// This function returns an array of handles for all currently connected
  /// monitors.  The primary monitor is always first in the returned array.  If no
  /// monitors were found, this function returns `NULL`.
  ///
  /// @param[out] count Where to store the number of monitors in the returned
  /// array.  This is set to zero if an error occurred.
  /// @return An array of monitor handles, or `NULL` if no monitors were found or
  /// if an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is guaranteed to be valid only until the
  /// monitor configuration changes or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_monitors
  /// @sa @ref monitor_event
  /// @sa @ref glfwGetPrimaryMonitor
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  ffi.Pointer<ffi.Pointer<GLFWmonitor>> glfwGetMonitors(
    ffi.Pointer<ffi.Int32> count,
  ) {
    return _glfwGetMonitors(
      count,
    );
  }

  late final _glfwGetMonitorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<GLFWmonitor>> Function(
              ffi.Pointer<ffi.Int32>)>>('glfwGetMonitors');
  late final _glfwGetMonitors = _glfwGetMonitorsPtr.asFunction<
      ffi.Pointer<ffi.Pointer<GLFWmonitor>> Function(ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the primary monitor.
  ///
  /// This function returns the primary monitor.  This is usually the monitor
  /// where elements like the task bar or global menu bar are located.
  ///
  /// @return The primary monitor, or `NULL` if no monitors were found or if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @remark The primary monitor is always first in the array returned by @ref
  /// glfwGetMonitors.
  ///
  /// @sa @ref monitor_monitors
  /// @sa @ref glfwGetMonitors
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  ffi.Pointer<GLFWmonitor> glfwGetPrimaryMonitor() {
    return _glfwGetPrimaryMonitor();
  }

  late final _glfwGetPrimaryMonitorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GLFWmonitor> Function()>>(
          'glfwGetPrimaryMonitor');
  late final _glfwGetPrimaryMonitor = _glfwGetPrimaryMonitorPtr
      .asFunction<ffi.Pointer<GLFWmonitor> Function()>();

  /// ! @brief Returns the position of the monitor's viewport on the virtual screen.
  ///
  /// This function returns the position, in screen coordinates, of the upper-left
  /// corner of the specified monitor.
  ///
  /// Any or all of the position arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` position arguments will be set to zero.
  ///
  /// @param[in] monitor The monitor to query.
  /// @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.
  /// @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_properties
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  void glfwGetMonitorPos(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Int32> xpos,
    ffi.Pointer<ffi.Int32> ypos,
  ) {
    return _glfwGetMonitorPos(
      monitor,
      xpos,
      ypos,
    );
  }

  late final _glfwGetMonitorPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetMonitorPos');
  late final _glfwGetMonitorPos = _glfwGetMonitorPosPtr.asFunction<
      void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Retrieves the work area of the monitor.
  ///
  /// This function returns the position, in screen coordinates, of the upper-left
  /// corner of the work area of the specified monitor along with the work area
  /// size in screen coordinates. The work area is defined as the area of the
  /// monitor not occluded by the operating system task bar where present. If no
  /// task bar exists then the work area is the monitor resolution in screen
  /// coordinates.
  ///
  /// Any or all of the position and size arguments may be `NULL`.  If an error
  /// occurs, all non-`NULL` position and size arguments will be set to zero.
  ///
  /// @param[in] monitor The monitor to query.
  /// @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.
  /// @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.
  /// @param[out] width Where to store the monitor width, or `NULL`.
  /// @param[out] height Where to store the monitor height, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_workarea
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup monitor
  void glfwGetMonitorWorkarea(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Int32> xpos,
    ffi.Pointer<ffi.Int32> ypos,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
  ) {
    return _glfwGetMonitorWorkarea(
      monitor,
      xpos,
      ypos,
      width,
      height,
    );
  }

  late final _glfwGetMonitorWorkareaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWmonitor>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetMonitorWorkarea');
  late final _glfwGetMonitorWorkarea = _glfwGetMonitorWorkareaPtr.asFunction<
      void Function(
          ffi.Pointer<GLFWmonitor>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the physical size of the monitor.
  ///
  /// This function returns the size, in millimetres, of the display area of the
  /// specified monitor.
  ///
  /// Some systems do not provide accurate monitor size information, either
  /// because the monitor
  /// [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)
  /// data is incorrect or because the driver does not report it accurately.
  ///
  /// Any or all of the size arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` size arguments will be set to zero.
  ///
  /// @param[in] monitor The monitor to query.
  /// @param[out] widthMM Where to store the width, in millimetres, of the
  /// monitor's display area, or `NULL`.
  /// @param[out] heightMM Where to store the height, in millimetres, of the
  /// monitor's display area, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @remark @win32 On Windows 8 and earlier the physical size is calculated from
  /// the current resolution and system DPI instead of querying the monitor EDID data.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_properties
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  void glfwGetMonitorPhysicalSize(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Int32> widthMM,
    ffi.Pointer<ffi.Int32> heightMM,
  ) {
    return _glfwGetMonitorPhysicalSize(
      monitor,
      widthMM,
      heightMM,
    );
  }

  late final _glfwGetMonitorPhysicalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetMonitorPhysicalSize');
  late final _glfwGetMonitorPhysicalSize =
      _glfwGetMonitorPhysicalSizePtr.asFunction<
          void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Retrieves the content scale for the specified monitor.
  ///
  /// This function retrieves the content scale for the specified monitor.  The
  /// content scale is the ratio between the current DPI and the platform's
  /// default DPI.  This is especially important for text and any UI elements.  If
  /// the pixel dimensions of your UI scaled by this look appropriate on your
  /// machine then it should appear at a reasonable size on other machines
  /// regardless of their DPI and scaling settings.  This relies on the system DPI
  /// and scaling settings being somewhat correct.
  ///
  /// The content scale may depend on both the monitor resolution and pixel
  /// density and on user settings.  It may be very different from the raw DPI
  /// calculated from the physical size and current resolution.
  ///
  /// @param[in] monitor The monitor to query.
  /// @param[out] xscale Where to store the x-axis content scale, or `NULL`.
  /// @param[out] yscale Where to store the y-axis content scale, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_scale
  /// @sa @ref glfwGetWindowContentScale
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup monitor
  void glfwGetMonitorContentScale(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Float> xscale,
    ffi.Pointer<ffi.Float> yscale,
  ) {
    return _glfwGetMonitorContentScale(
      monitor,
      xscale,
      yscale,
    );
  }

  late final _glfwGetMonitorContentScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('glfwGetMonitorContentScale');
  late final _glfwGetMonitorContentScale =
      _glfwGetMonitorContentScalePtr.asFunction<
          void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>();

  /// ! @brief Returns the name of the specified monitor.
  ///
  /// This function returns a human-readable name, encoded as UTF-8, of the
  /// specified monitor.  The name typically reflects the make and model of the
  /// monitor and is not guaranteed to be unique among the connected monitors.
  ///
  /// @param[in] monitor The monitor to query.
  /// @return The UTF-8 encoded name of the monitor, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified monitor is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_properties
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  ffi.Pointer<ffi.Int8> glfwGetMonitorName(
    ffi.Pointer<GLFWmonitor> monitor,
  ) {
    return _glfwGetMonitorName(
      monitor,
    );
  }

  late final _glfwGetMonitorNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<GLFWmonitor>)>>('glfwGetMonitorName');
  late final _glfwGetMonitorName = _glfwGetMonitorNamePtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(ffi.Pointer<GLFWmonitor>)>();

  /// ! @brief Sets the user pointer of the specified monitor.
  ///
  /// This function sets the user-defined pointer of the specified monitor.  The
  /// current value is retained until the monitor is disconnected.  The initial
  /// value is `NULL`.
  ///
  /// This function may be called from the monitor callback, even for a monitor
  /// that is being disconnected.
  ///
  /// @param[in] monitor The monitor whose pointer to set.
  /// @param[in] pointer The new value.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref monitor_userptr
  /// @sa @ref glfwGetMonitorUserPointer
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup monitor
  void glfwSetMonitorUserPointer(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Void> pointer,
  ) {
    return _glfwSetMonitorUserPointer(
      monitor,
      pointer,
    );
  }

  late final _glfwSetMonitorUserPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWmonitor>,
              ffi.Pointer<ffi.Void>)>>('glfwSetMonitorUserPointer');
  late final _glfwSetMonitorUserPointer =
      _glfwSetMonitorUserPointerPtr.asFunction<
          void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Void>)>();

  /// ! @brief Returns the user pointer of the specified monitor.
  ///
  /// This function returns the current value of the user-defined pointer of the
  /// specified monitor.  The initial value is `NULL`.
  ///
  /// This function may be called from the monitor callback, even for a monitor
  /// that is being disconnected.
  ///
  /// @param[in] monitor The monitor whose pointer to return.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref monitor_userptr
  /// @sa @ref glfwSetMonitorUserPointer
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup monitor
  ffi.Pointer<ffi.Void> glfwGetMonitorUserPointer(
    ffi.Pointer<GLFWmonitor> monitor,
  ) {
    return _glfwGetMonitorUserPointer(
      monitor,
    );
  }

  late final _glfwGetMonitorUserPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GLFWmonitor>)>>('glfwGetMonitorUserPointer');
  late final _glfwGetMonitorUserPointer = _glfwGetMonitorUserPointerPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GLFWmonitor>)>();

  /// ! @brief Sets the monitor configuration callback.
  ///
  /// This function sets the monitor configuration callback, or removes the
  /// currently set callback.  This is called when a monitor is connected to or
  /// disconnected from the system.
  ///
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWmonitor* monitor, int event)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWmonitorfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_event
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  GLFWmonitorfun glfwSetMonitorCallback(
    GLFWmonitorfun callback,
  ) {
    return _glfwSetMonitorCallback(
      callback,
    );
  }

  late final _glfwSetMonitorCallbackPtr =
      _lookup<ffi.NativeFunction<GLFWmonitorfun Function(GLFWmonitorfun)>>(
          'glfwSetMonitorCallback');
  late final _glfwSetMonitorCallback = _glfwSetMonitorCallbackPtr
      .asFunction<GLFWmonitorfun Function(GLFWmonitorfun)>();

  /// ! @brief Returns the available video modes for the specified monitor.
  ///
  /// This function returns an array of all video modes supported by the specified
  /// monitor.  The returned array is sorted in ascending order, first by color
  /// bit depth (the sum of all channel depths), then by resolution area (the
  /// product of width and height), then resolution width and finally by refresh
  /// rate.
  ///
  /// @param[in] monitor The monitor to query.
  /// @param[out] count Where to store the number of video modes in the returned
  /// array.  This is set to zero if an error occurred.
  /// @return An array of video modes, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified monitor is
  /// disconnected, this function is called again for that monitor or the library
  /// is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_modes
  /// @sa @ref glfwGetVideoMode
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Changed to return an array of modes for a specific monitor.
  ///
  /// @ingroup monitor
  ffi.Pointer<GLFWvidmode> glfwGetVideoModes(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<ffi.Int32> count,
  ) {
    return _glfwGetVideoModes(
      monitor,
      count,
    );
  }

  late final _glfwGetVideoModesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWvidmode> Function(ffi.Pointer<GLFWmonitor>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetVideoModes');
  late final _glfwGetVideoModes = _glfwGetVideoModesPtr.asFunction<
      ffi.Pointer<GLFWvidmode> Function(
          ffi.Pointer<GLFWmonitor>, ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the current mode of the specified monitor.
  ///
  /// This function returns the current video mode of the specified monitor.  If
  /// you have created a full screen window for that monitor, the return value
  /// will depend on whether that window is iconified.
  ///
  /// @param[in] monitor The monitor to query.
  /// @return The current mode of the monitor, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified monitor is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_modes
  /// @sa @ref glfwGetVideoModes
  ///
  /// @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.
  ///
  /// @ingroup monitor
  ffi.Pointer<GLFWvidmode> glfwGetVideoMode(
    ffi.Pointer<GLFWmonitor> monitor,
  ) {
    return _glfwGetVideoMode(
      monitor,
    );
  }

  late final _glfwGetVideoModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWvidmode> Function(
              ffi.Pointer<GLFWmonitor>)>>('glfwGetVideoMode');
  late final _glfwGetVideoMode = _glfwGetVideoModePtr.asFunction<
      ffi.Pointer<GLFWvidmode> Function(ffi.Pointer<GLFWmonitor>)>();

  /// ! @brief Generates a gamma ramp and sets it for the specified monitor.
  ///
  /// This function generates an appropriately sized gamma ramp from the specified
  /// exponent and then calls @ref glfwSetGammaRamp with it.  The value must be
  /// a finite number greater than zero.
  ///
  /// The software controlled gamma ramp is applied _in addition_ to the hardware
  /// gamma correction, which today is usually an approximation of sRGB gamma.
  /// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
  /// the default (usually sRGB-like) behavior.
  ///
  /// For gamma correct rendering with OpenGL or OpenGL ES, see the @ref
  /// GLFW_SRGB_CAPABLE hint.
  ///
  /// @param[in] monitor The monitor whose gamma ramp to set.
  /// @param[in] gamma The desired exponent.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland Gamma handling is a privileged protocol, this function
  /// will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_gamma
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  void glfwSetGamma(
    ffi.Pointer<GLFWmonitor> monitor,
    double gamma,
  ) {
    return _glfwSetGamma(
      monitor,
      gamma,
    );
  }

  late final _glfwSetGammaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWmonitor>, ffi.Float)>>('glfwSetGamma');
  late final _glfwSetGamma = _glfwSetGammaPtr
      .asFunction<void Function(ffi.Pointer<GLFWmonitor>, double)>();

  /// ! @brief Returns the current gamma ramp for the specified monitor.
  ///
  /// This function returns the current gamma ramp of the specified monitor.
  ///
  /// @param[in] monitor The monitor to query.
  /// @return The current gamma ramp, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland Gamma handling is a privileged protocol, this function
  /// will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR while
  /// returning `NULL`.
  ///
  /// @pointer_lifetime The returned structure and its arrays are allocated and
  /// freed by GLFW.  You should not free them yourself.  They are valid until the
  /// specified monitor is disconnected, this function is called again for that
  /// monitor or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_gamma
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  ffi.Pointer<GLFWgammaramp> glfwGetGammaRamp(
    ffi.Pointer<GLFWmonitor> monitor,
  ) {
    return _glfwGetGammaRamp(
      monitor,
    );
  }

  late final _glfwGetGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWgammaramp> Function(
              ffi.Pointer<GLFWmonitor>)>>('glfwGetGammaRamp');
  late final _glfwGetGammaRamp = _glfwGetGammaRampPtr.asFunction<
      ffi.Pointer<GLFWgammaramp> Function(ffi.Pointer<GLFWmonitor>)>();

  /// ! @brief Sets the current gamma ramp for the specified monitor.
  ///
  /// This function sets the current gamma ramp for the specified monitor.  The
  /// original gamma ramp for that monitor is saved by GLFW the first time this
  /// function is called and is restored by @ref glfwTerminate.
  ///
  /// The software controlled gamma ramp is applied _in addition_ to the hardware
  /// gamma correction, which today is usually an approximation of sRGB gamma.
  /// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
  /// the default (usually sRGB-like) behavior.
  ///
  /// For gamma correct rendering with OpenGL or OpenGL ES, see the @ref
  /// GLFW_SRGB_CAPABLE hint.
  ///
  /// @param[in] monitor The monitor whose gamma ramp to set.
  /// @param[in] ramp The gamma ramp to use.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark The size of the specified gamma ramp should match the size of the
  /// current ramp for that monitor.
  ///
  /// @remark @win32 The gamma ramp size must be 256.
  ///
  /// @remark @wayland Gamma handling is a privileged protocol, this function
  /// will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The specified gamma ramp is copied before this function
  /// returns.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref monitor_gamma
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup monitor
  void glfwSetGammaRamp(
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<GLFWgammaramp> ramp,
  ) {
    return _glfwSetGammaRamp(
      monitor,
      ramp,
    );
  }

  late final _glfwSetGammaRampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWmonitor>,
              ffi.Pointer<GLFWgammaramp>)>>('glfwSetGammaRamp');
  late final _glfwSetGammaRamp = _glfwSetGammaRampPtr.asFunction<
      void Function(ffi.Pointer<GLFWmonitor>, ffi.Pointer<GLFWgammaramp>)>();

  /// ! @brief Resets all window hints to their default values.
  ///
  /// This function resets all window hints to their
  /// [default values](@ref window_hints_values).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_hints
  /// @sa @ref glfwWindowHint
  /// @sa @ref glfwWindowHintString
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwDefaultWindowHints() {
    return _glfwDefaultWindowHints();
  }

  late final _glfwDefaultWindowHintsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'glfwDefaultWindowHints');
  late final _glfwDefaultWindowHints =
      _glfwDefaultWindowHintsPtr.asFunction<void Function()>();

  /// ! @brief Sets the specified window hint to the desired value.
  ///
  /// This function sets hints for the next call to @ref glfwCreateWindow.  The
  /// hints, once set, retain their values until changed by a call to this
  /// function or @ref glfwDefaultWindowHints, or until the library is terminated.
  ///
  /// Only integer value hints can be set with this function.  String value hints
  /// are set with @ref glfwWindowHintString.
  ///
  /// This function does not check whether the specified hint values are valid.
  /// If you set hints to invalid values this will instead be reported by the next
  /// call to @ref glfwCreateWindow.
  ///
  /// Some hints are platform specific.  These may be set on any platform but they
  /// will only affect their specific platform.  Other platforms will ignore them.
  /// Setting these hints requires no platform specific headers or functions.
  ///
  /// @param[in] hint The [window hint](@ref window_hints) to set.
  /// @param[in] value The new value of the window hint.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_hints
  /// @sa @ref glfwWindowHintString
  /// @sa @ref glfwDefaultWindowHints
  ///
  /// @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.
  ///
  /// @ingroup window
  void glfwWindowHint(
    int hint,
    int value,
  ) {
    return _glfwWindowHint(
      hint,
      value,
    );
  }

  late final _glfwWindowHintPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'glfwWindowHint');
  late final _glfwWindowHint =
      _glfwWindowHintPtr.asFunction<void Function(int, int)>();

  /// ! @brief Sets the specified window hint to the desired value.
  ///
  /// This function sets hints for the next call to @ref glfwCreateWindow.  The
  /// hints, once set, retain their values until changed by a call to this
  /// function or @ref glfwDefaultWindowHints, or until the library is terminated.
  ///
  /// Only string type hints can be set with this function.  Integer value hints
  /// are set with @ref glfwWindowHint.
  ///
  /// This function does not check whether the specified hint values are valid.
  /// If you set hints to invalid values this will instead be reported by the next
  /// call to @ref glfwCreateWindow.
  ///
  /// Some hints are platform specific.  These may be set on any platform but they
  /// will only affect their specific platform.  Other platforms will ignore them.
  /// Setting these hints requires no platform specific headers or functions.
  ///
  /// @param[in] hint The [window hint](@ref window_hints) to set.
  /// @param[in] value The new value of the window hint.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @pointer_lifetime The specified string is copied before this function
  /// returns.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_hints
  /// @sa @ref glfwWindowHint
  /// @sa @ref glfwDefaultWindowHints
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  void glfwWindowHintString(
    int hint,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _glfwWindowHintString(
      hint,
      value,
    );
  }

  late final _glfwWindowHintStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('glfwWindowHintString');
  late final _glfwWindowHintString = _glfwWindowHintStringPtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Creates a window and its associated context.
  ///
  /// This function creates a window and its associated OpenGL or OpenGL ES
  /// context.  Most of the options controlling how the window and its context
  /// should be created are specified with [window hints](@ref window_hints).
  ///
  /// Successful creation does not change which context is current.  Before you
  /// can use the newly created context, you need to
  /// [make it current](@ref context_current).  For information about the `share`
  /// parameter, see @ref context_sharing.
  ///
  /// The created window, framebuffer and context may differ from what you
  /// requested, as not all parameters and hints are
  /// [hard constraints](@ref window_hints_hard).  This includes the size of the
  /// window, especially for full screen windows.  To query the actual attributes
  /// of the created window, framebuffer and context, see @ref
  /// glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize.
  ///
  /// To create a full screen window, you need to specify the monitor the window
  /// will cover.  If no monitor is specified, the window will be windowed mode.
  /// Unless you have a way for the user to choose a specific monitor, it is
  /// recommended that you pick the primary monitor.  For more information on how
  /// to query connected monitors, see @ref monitor_monitors.
  ///
  /// For full screen windows, the specified size becomes the resolution of the
  /// window's _desired video mode_.  As long as a full screen window is not
  /// iconified, the supported video mode most closely matching the desired video
  /// mode is set for the specified monitor.  For more information about full
  /// screen windows, including the creation of so called _windowed full screen_
  /// or _borderless full screen_ windows, see @ref window_windowed_full_screen.
  ///
  /// Once you have created the window, you can switch it between windowed and
  /// full screen mode with @ref glfwSetWindowMonitor.  This will not affect its
  /// OpenGL or OpenGL ES context.
  ///
  /// By default, newly created windows use the placement recommended by the
  /// window system.  To create the window at a specific position, make it
  /// initially invisible using the [GLFW_VISIBLE](@ref GLFW_VISIBLE_hint) window
  /// hint, set its [position](@ref window_pos) and then [show](@ref window_hide)
  /// it.
  ///
  /// As long as at least one full screen window is not iconified, the screensaver
  /// is prohibited from starting.
  ///
  /// Window systems put limits on window sizes.  Very large or very small window
  /// dimensions may be overridden by the window system on creation.  Check the
  /// actual [size](@ref window_size) after creation.
  ///
  /// The [swap interval](@ref buffer_swap) is not set during window creation and
  /// the initial value may vary depending on driver settings and defaults.
  ///
  /// @param[in] width The desired width, in screen coordinates, of the window.
  /// This must be greater than zero.
  /// @param[in] height The desired height, in screen coordinates, of the window.
  /// This must be greater than zero.
  /// @param[in] title The initial, UTF-8 encoded window title.
  /// @param[in] monitor The monitor to use for full screen mode, or `NULL` for
  /// windowed mode.
  /// @param[in] share The window whose context to share resources with, or `NULL`
  /// to not share resources.
  /// @return The handle of the created window, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref
  /// GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @win32 Window creation will fail if the Microsoft GDI software
  /// OpenGL implementation is the only one available.
  ///
  /// @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it
  /// will be set as the initial icon for the window.  If no such icon is present,
  /// the `IDI_APPLICATION` icon will be used instead.  To set a different icon,
  /// see @ref glfwSetWindowIcon.
  ///
  /// @remark @win32 The context to share resources with must not be current on
  /// any other thread.
  ///
  /// @remark @macos The OS only supports forward-compatible core profile contexts
  /// for OpenGL versions 3.2 and later.  Before creating an OpenGL context of
  /// version 3.2 or later you must set the
  /// [GLFW_OPENGL_FORWARD_COMPAT](@ref GLFW_OPENGL_FORWARD_COMPAT_hint) and
  /// [GLFW_OPENGL_PROFILE](@ref GLFW_OPENGL_PROFILE_hint) hints accordingly.
  /// OpenGL 3.0 and 3.1 contexts are not supported at all on macOS.
  ///
  /// @remark @macos The GLFW window has no icon, as it is not a document
  /// window, but the dock icon will be the same as the application bundle's icon.
  /// For more information on bundles, see the
  /// [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)
  /// in the Mac Developer Library.
  ///
  /// @remark @macos The first time a window is created the menu bar is created.
  /// If GLFW finds a `MainMenu.nib` it is loaded and assumed to contain a menu
  /// bar.  Otherwise a minimal menu bar is created manually with common commands
  /// like Hide, Quit and About.  The About entry opens a minimal about dialog
  /// with information from the application's bundle.  Menu bar creation can be
  /// disabled entirely with the @ref GLFW_COCOA_MENUBAR init hint.
  ///
  /// @remark @macos On OS X 10.10 and later the window frame will not be rendered
  /// at full resolution on Retina displays unless the
  /// [GLFW_COCOA_RETINA_FRAMEBUFFER](@ref GLFW_COCOA_RETINA_FRAMEBUFFER_hint)
  /// hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the
  /// application bundle's `Info.plist`.  For more information, see
  /// [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)
  /// in the Mac Developer Library.  The GLFW test and example programs use
  /// a custom `Info.plist` template for this, which can be found as
  /// `CMake/MacOSXBundleInfo.plist.in` in the source tree.
  ///
  /// @remark @macos When activating frame autosaving with
  /// [GLFW_COCOA_FRAME_NAME](@ref GLFW_COCOA_FRAME_NAME_hint), the specified
  /// window size and position may be overridden by previously saved values.
  ///
  /// @remark @x11 Some window managers will not respect the placement of
  /// initially hidden windows.
  ///
  /// @remark @x11 Due to the asynchronous nature of X11, it may take a moment for
  /// a window to reach its requested state.  This means you may not be able to
  /// query the final size, position or other attributes directly after window
  /// creation.
  ///
  /// @remark @x11 The class part of the `WM_CLASS` window property will by
  /// default be set to the window title passed to this function.  The instance
  /// part will use the contents of the `RESOURCE_NAME` environment variable, if
  /// present and not empty, or fall back to the window title.  Set the
  /// [GLFW_X11_CLASS_NAME](@ref GLFW_X11_CLASS_NAME_hint) and
  /// [GLFW_X11_INSTANCE_NAME](@ref GLFW_X11_INSTANCE_NAME_hint) window hints to
  /// override this.
  ///
  /// @remark @wayland Compositors should implement the xdg-decoration protocol
  /// for GLFW to decorate the window properly.  If this protocol isn't
  /// supported, or if the compositor prefers client-side decorations, a very
  /// simple fallback frame will be drawn using the wp_viewporter protocol.  A
  /// compositor can still emit close, maximize or fullscreen events, using for
  /// instance a keybind mechanism.  If neither of these protocols is supported,
  /// the window won't be decorated.
  ///
  /// @remark @wayland A full screen window will not attempt to change the mode,
  /// no matter what the requested size or refresh rate.
  ///
  /// @remark @wayland Screensaver inhibition requires the idle-inhibit protocol
  /// to be implemented in the user's compositor.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_creation
  /// @sa @ref glfwDestroyWindow
  ///
  /// @since Added in version 3.0.  Replaces `glfwOpenWindow`.
  ///
  /// @ingroup window
  ffi.Pointer<GLFWwindow> glfwCreateWindow(
    int width,
    int height,
    ffi.Pointer<ffi.Int8> title,
    ffi.Pointer<GLFWmonitor> monitor,
    ffi.Pointer<GLFWwindow> share,
  ) {
    return _glfwCreateWindow(
      width,
      height,
      title,
      monitor,
      share,
    );
  }

  late final _glfwCreateWindowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWwindow> Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<GLFWmonitor>,
              ffi.Pointer<GLFWwindow>)>>('glfwCreateWindow');
  late final _glfwCreateWindow = _glfwCreateWindowPtr.asFunction<
      ffi.Pointer<GLFWwindow> Function(int, int, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<GLFWmonitor>, ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Destroys the specified window and its context.
  ///
  /// This function destroys the specified window and its context.  On calling
  /// this function, no further callbacks will be called for that window.
  ///
  /// If the context of the specified window is current on the main thread, it is
  /// detached before being destroyed.
  ///
  /// @param[in] window The window to destroy.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @note The context of the specified window must not be current on any other
  /// thread when this function is called.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_creation
  /// @sa @ref glfwCreateWindow
  ///
  /// @since Added in version 3.0.  Replaces `glfwCloseWindow`.
  ///
  /// @ingroup window
  void glfwDestroyWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwDestroyWindow(
      window,
    );
  }

  late final _glfwDestroyWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwDestroyWindow');
  late final _glfwDestroyWindow = _glfwDestroyWindowPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Checks the close flag of the specified window.
  ///
  /// This function returns the value of the close flag of the specified window.
  ///
  /// @param[in] window The window to query.
  /// @return The value of the close flag.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref window_close
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  int glfwWindowShouldClose(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwWindowShouldClose(
      window,
    );
  }

  late final _glfwWindowShouldClosePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwWindowShouldClose');
  late final _glfwWindowShouldClose = _glfwWindowShouldClosePtr
      .asFunction<int Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Sets the close flag of the specified window.
  ///
  /// This function sets the value of the close flag of the specified window.
  /// This can be used to override the user's attempt to close the window, or
  /// to signal that it should be closed.
  ///
  /// @param[in] window The window whose flag to change.
  /// @param[in] value The new value.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref window_close
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwSetWindowShouldClose(
    ffi.Pointer<GLFWwindow> window,
    int value,
  ) {
    return _glfwSetWindowShouldClose(
      window,
      value,
    );
  }

  late final _glfwSetWindowShouldClosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWwindow>, ffi.Int32)>>('glfwSetWindowShouldClose');
  late final _glfwSetWindowShouldClose = _glfwSetWindowShouldClosePtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int)>();

  /// ! @brief Sets the title of the specified window.
  ///
  /// This function sets the window title, encoded as UTF-8, of the specified
  /// window.
  ///
  /// @param[in] window The window whose title to change.
  /// @param[in] title The UTF-8 encoded window title.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @macos The window title will not be updated until the next time you
  /// process events.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_title
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwSetWindowTitle(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int8> title,
  ) {
    return _glfwSetWindowTitle(
      window,
      title,
    );
  }

  late final _glfwSetWindowTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>,
              ffi.Pointer<ffi.Int8>)>>('glfwSetWindowTitle');
  late final _glfwSetWindowTitle = _glfwSetWindowTitlePtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Sets the icon for the specified window.
  ///
  /// This function sets the icon of the specified window.  If passed an array of
  /// candidate images, those of or closest to the sizes desired by the system are
  /// selected.  If no images are specified, the window reverts to its default
  /// icon.
  ///
  /// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
  /// bits per channel with the red channel first.  They are arranged canonically
  /// as packed sequential rows, starting from the top-left corner.
  ///
  /// The desired image sizes varies depending on platform and system settings.
  /// The selected images will be rescaled as needed.  Good sizes include 16x16,
  /// 32x32 and 48x48.
  ///
  /// @param[in] window The window whose icon to set.
  /// @param[in] count The number of images in the specified array, or zero to
  /// revert to the default window icon.
  /// @param[in] images The images to create the icon from.  This is ignored if
  /// count is zero.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The specified image data is copied before this function
  /// returns.
  ///
  /// @remark @macos The GLFW window has no icon, as it is not a document
  /// window, so this function does nothing.  The dock icon will be the same as
  /// the application bundle's icon.  For more information on bundles, see the
  /// [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)
  /// in the Mac Developer Library.
  ///
  /// @remark @wayland There is no existing protocol to change an icon, the
  /// window will thus inherit the one defined in the application's desktop file.
  /// This function always emits @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_icon
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwSetWindowIcon(
    ffi.Pointer<GLFWwindow> window,
    int count,
    ffi.Pointer<GLFWimage> images,
  ) {
    return _glfwSetWindowIcon(
      window,
      count,
      images,
    );
  }

  late final _glfwSetWindowIconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Pointer<GLFWimage>)>>('glfwSetWindowIcon');
  late final _glfwSetWindowIcon = _glfwSetWindowIconPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, int, ffi.Pointer<GLFWimage>)>();

  /// ! @brief Retrieves the position of the content area of the specified window.
  ///
  /// This function retrieves the position, in screen coordinates, of the
  /// upper-left corner of the content area of the specified window.
  ///
  /// Any or all of the position arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` position arguments will be set to zero.
  ///
  /// @param[in] window The window to query.
  /// @param[out] xpos Where to store the x-coordinate of the upper-left corner of
  /// the content area, or `NULL`.
  /// @param[out] ypos Where to store the y-coordinate of the upper-left corner of
  /// the content area, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland There is no way for an application to retrieve the global
  /// position of its windows, this function will always emit @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_pos
  /// @sa @ref glfwSetWindowPos
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwGetWindowPos(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int32> xpos,
    ffi.Pointer<ffi.Int32> ypos,
  ) {
    return _glfwGetWindowPos(
      window,
      xpos,
      ypos,
    );
  }

  late final _glfwGetWindowPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetWindowPos');
  late final _glfwGetWindowPos = _glfwGetWindowPosPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Sets the position of the content area of the specified window.
  ///
  /// This function sets the position, in screen coordinates, of the upper-left
  /// corner of the content area of the specified windowed mode window.  If the
  /// window is a full screen window, this function does nothing.
  ///
  /// __Do not use this function__ to move an already visible window unless you
  /// have very good reasons for doing so, as it will confuse and annoy the user.
  ///
  /// The window manager may put limits on what positions are allowed.  GLFW
  /// cannot and should not override these limits.
  ///
  /// @param[in] window The window to query.
  /// @param[in] xpos The x-coordinate of the upper-left corner of the content area.
  /// @param[in] ypos The y-coordinate of the upper-left corner of the content area.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland There is no way for an application to set the global
  /// position of its windows, this function will always emit @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_pos
  /// @sa @ref glfwGetWindowPos
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwSetWindowPos(
    ffi.Pointer<GLFWwindow> window,
    int xpos,
    int ypos,
  ) {
    return _glfwSetWindowPos(
      window,
      xpos,
      ypos,
    );
  }

  late final _glfwSetWindowPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Int32)>>('glfwSetWindowPos');
  late final _glfwSetWindowPos = _glfwSetWindowPosPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int)>();

  /// ! @brief Retrieves the size of the content area of the specified window.
  ///
  /// This function retrieves the size, in screen coordinates, of the content area
  /// of the specified window.  If you wish to retrieve the size of the
  /// framebuffer of the window in pixels, see @ref glfwGetFramebufferSize.
  ///
  /// Any or all of the size arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` size arguments will be set to zero.
  ///
  /// @param[in] window The window whose size to retrieve.
  /// @param[out] width Where to store the width, in screen coordinates, of the
  /// content area, or `NULL`.
  /// @param[out] height Where to store the height, in screen coordinates, of the
  /// content area, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_size
  /// @sa @ref glfwSetWindowSize
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwGetWindowSize(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
  ) {
    return _glfwGetWindowSize(
      window,
      width,
      height,
    );
  }

  late final _glfwGetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetWindowSize');
  late final _glfwGetWindowSize = _glfwGetWindowSizePtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Sets the size limits of the specified window.
  ///
  /// This function sets the size limits of the content area of the specified
  /// window.  If the window is full screen, the size limits only take effect
  /// once it is made windowed.  If the window is not resizable, this function
  /// does nothing.
  ///
  /// The size limits are applied immediately to a windowed mode window and may
  /// cause it to be resized.
  ///
  /// The maximum dimensions must be greater than or equal to the minimum
  /// dimensions and all must be greater than or equal to zero.
  ///
  /// @param[in] window The window to set limits for.
  /// @param[in] minwidth The minimum width, in screen coordinates, of the content
  /// area, or `GLFW_DONT_CARE`.
  /// @param[in] minheight The minimum height, in screen coordinates, of the
  /// content area, or `GLFW_DONT_CARE`.
  /// @param[in] maxwidth The maximum width, in screen coordinates, of the content
  /// area, or `GLFW_DONT_CARE`.
  /// @param[in] maxheight The maximum height, in screen coordinates, of the
  /// content area, or `GLFW_DONT_CARE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark If you set size limits and an aspect ratio that conflict, the
  /// results are undefined.
  ///
  /// @remark @wayland The size limits will not be applied until the window is
  /// actually resized, either by the user or by the compositor.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_sizelimits
  /// @sa @ref glfwSetWindowAspectRatio
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwSetWindowSizeLimits(
    ffi.Pointer<GLFWwindow> window,
    int minwidth,
    int minheight,
    int maxwidth,
    int maxheight,
  ) {
    return _glfwSetWindowSizeLimits(
      window,
      minwidth,
      minheight,
      maxwidth,
      maxheight,
    );
  }

  late final _glfwSetWindowSizeLimitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('glfwSetWindowSizeLimits');
  late final _glfwSetWindowSizeLimits = _glfwSetWindowSizeLimitsPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int, int, int)>();

  /// ! @brief Sets the aspect ratio of the specified window.
  ///
  /// This function sets the required aspect ratio of the content area of the
  /// specified window.  If the window is full screen, the aspect ratio only takes
  /// effect once it is made windowed.  If the window is not resizable, this
  /// function does nothing.
  ///
  /// The aspect ratio is specified as a numerator and a denominator and both
  /// values must be greater than zero.  For example, the common 16:9 aspect ratio
  /// is specified as 16 and 9, respectively.
  ///
  /// If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
  /// ratio limit is disabled.
  ///
  /// The aspect ratio is applied immediately to a windowed mode window and may
  /// cause it to be resized.
  ///
  /// @param[in] window The window to set limits for.
  /// @param[in] numer The numerator of the desired aspect ratio, or
  /// `GLFW_DONT_CARE`.
  /// @param[in] denom The denominator of the desired aspect ratio, or
  /// `GLFW_DONT_CARE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark If you set size limits and an aspect ratio that conflict, the
  /// results are undefined.
  ///
  /// @remark @wayland The aspect ratio will not be applied until the window is
  /// actually resized, either by the user or by the compositor.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_sizelimits
  /// @sa @ref glfwSetWindowSizeLimits
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwSetWindowAspectRatio(
    ffi.Pointer<GLFWwindow> window,
    int numer,
    int denom,
  ) {
    return _glfwSetWindowAspectRatio(
      window,
      numer,
      denom,
    );
  }

  late final _glfwSetWindowAspectRatioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Int32)>>('glfwSetWindowAspectRatio');
  late final _glfwSetWindowAspectRatio = _glfwSetWindowAspectRatioPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int)>();

  /// ! @brief Sets the size of the content area of the specified window.
  ///
  /// This function sets the size, in screen coordinates, of the content area of
  /// the specified window.
  ///
  /// For full screen windows, this function updates the resolution of its desired
  /// video mode and switches to the video mode closest to it, without affecting
  /// the window's context.  As the context is unaffected, the bit depths of the
  /// framebuffer remain unchanged.
  ///
  /// If you wish to update the refresh rate of the desired video mode in addition
  /// to its resolution, see @ref glfwSetWindowMonitor.
  ///
  /// The window manager may put limits on what sizes are allowed.  GLFW cannot
  /// and should not override these limits.
  ///
  /// @param[in] window The window to resize.
  /// @param[in] width The desired width, in screen coordinates, of the window
  /// content area.
  /// @param[in] height The desired height, in screen coordinates, of the window
  /// content area.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland A full screen window will not attempt to change the mode,
  /// no matter what the requested size.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_size
  /// @sa @ref glfwGetWindowSize
  /// @sa @ref glfwSetWindowMonitor
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwSetWindowSize(
    ffi.Pointer<GLFWwindow> window,
    int width,
    int height,
  ) {
    return _glfwSetWindowSize(
      window,
      width,
      height,
    );
  }

  late final _glfwSetWindowSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Int32)>>('glfwSetWindowSize');
  late final _glfwSetWindowSize = _glfwSetWindowSizePtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int)>();

  /// ! @brief Retrieves the size of the framebuffer of the specified window.
  ///
  /// This function retrieves the size, in pixels, of the framebuffer of the
  /// specified window.  If you wish to retrieve the size of the window in screen
  /// coordinates, see @ref glfwGetWindowSize.
  ///
  /// Any or all of the size arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` size arguments will be set to zero.
  ///
  /// @param[in] window The window whose framebuffer to query.
  /// @param[out] width Where to store the width, in pixels, of the framebuffer,
  /// or `NULL`.
  /// @param[out] height Where to store the height, in pixels, of the framebuffer,
  /// or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_fbsize
  /// @sa @ref glfwSetFramebufferSizeCallback
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwGetFramebufferSize(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
  ) {
    return _glfwGetFramebufferSize(
      window,
      width,
      height,
    );
  }

  late final _glfwGetFramebufferSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetFramebufferSize');
  late final _glfwGetFramebufferSize = _glfwGetFramebufferSizePtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Retrieves the size of the frame of the window.
  ///
  /// This function retrieves the size, in screen coordinates, of each edge of the
  /// frame of the specified window.  This size includes the title bar, if the
  /// window has one.  The size of the frame may vary depending on the
  /// [window-related hints](@ref window_hints_wnd) used to create it.
  ///
  /// Because this function retrieves the size of each window frame edge and not
  /// the offset along a particular coordinate axis, the retrieved values will
  /// always be zero or positive.
  ///
  /// Any or all of the size arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` size arguments will be set to zero.
  ///
  /// @param[in] window The window whose frame size to query.
  /// @param[out] left Where to store the size, in screen coordinates, of the left
  /// edge of the window frame, or `NULL`.
  /// @param[out] top Where to store the size, in screen coordinates, of the top
  /// edge of the window frame, or `NULL`.
  /// @param[out] right Where to store the size, in screen coordinates, of the
  /// right edge of the window frame, or `NULL`.
  /// @param[out] bottom Where to store the size, in screen coordinates, of the
  /// bottom edge of the window frame, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_size
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup window
  void glfwGetWindowFrameSize(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int32> left,
    ffi.Pointer<ffi.Int32> top,
    ffi.Pointer<ffi.Int32> right,
    ffi.Pointer<ffi.Int32> bottom,
  ) {
    return _glfwGetWindowFrameSize(
      window,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _glfwGetWindowFrameSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWwindow>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('glfwGetWindowFrameSize');
  late final _glfwGetWindowFrameSize = _glfwGetWindowFrameSizePtr.asFunction<
      void Function(
          ffi.Pointer<GLFWwindow>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Retrieves the content scale for the specified window.
  ///
  /// This function retrieves the content scale for the specified window.  The
  /// content scale is the ratio between the current DPI and the platform's
  /// default DPI.  This is especially important for text and any UI elements.  If
  /// the pixel dimensions of your UI scaled by this look appropriate on your
  /// machine then it should appear at a reasonable size on other machines
  /// regardless of their DPI and scaling settings.  This relies on the system DPI
  /// and scaling settings being somewhat correct.
  ///
  /// On systems where each monitors can have its own content scale, the window
  /// content scale will depend on which monitor the system considers the window
  /// to be on.
  ///
  /// @param[in] window The window to query.
  /// @param[out] xscale Where to store the x-axis content scale, or `NULL`.
  /// @param[out] yscale Where to store the y-axis content scale, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_scale
  /// @sa @ref glfwSetWindowContentScaleCallback
  /// @sa @ref glfwGetMonitorContentScale
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  void glfwGetWindowContentScale(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Float> xscale,
    ffi.Pointer<ffi.Float> yscale,
  ) {
    return _glfwGetWindowContentScale(
      window,
      xscale,
      yscale,
    );
  }

  late final _glfwGetWindowContentScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('glfwGetWindowContentScale');
  late final _glfwGetWindowContentScale =
      _glfwGetWindowContentScalePtr.asFunction<
          void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>();

  /// ! @brief Returns the opacity of the whole window.
  ///
  /// This function returns the opacity of the window, including any decorations.
  ///
  /// The opacity (or alpha) value is a positive finite number between zero and
  /// one, where zero is fully transparent and one is fully opaque.  If the system
  /// does not support whole window transparency, this function always returns one.
  ///
  /// The initial opacity value for newly created windows is one.
  ///
  /// @param[in] window The window to query.
  /// @return The opacity value of the specified window.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_transparency
  /// @sa @ref glfwSetWindowOpacity
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  double glfwGetWindowOpacity(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwGetWindowOpacity(
      window,
    );
  }

  late final _glfwGetWindowOpacityPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwGetWindowOpacity');
  late final _glfwGetWindowOpacity = _glfwGetWindowOpacityPtr
      .asFunction<double Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Sets the opacity of the whole window.
  ///
  /// This function sets the opacity of the window, including any decorations.
  ///
  /// The opacity (or alpha) value is a positive finite number between zero and
  /// one, where zero is fully transparent and one is fully opaque.
  ///
  /// The initial opacity value for newly created windows is one.
  ///
  /// A window created with framebuffer transparency may not use whole window
  /// transparency.  The results of doing this are undefined.
  ///
  /// @param[in] window The window to set the opacity for.
  /// @param[in] opacity The desired opacity of the specified window.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_transparency
  /// @sa @ref glfwGetWindowOpacity
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  void glfwSetWindowOpacity(
    ffi.Pointer<GLFWwindow> window,
    double opacity,
  ) {
    return _glfwSetWindowOpacity(
      window,
      opacity,
    );
  }

  late final _glfwSetWindowOpacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWwindow>, ffi.Float)>>('glfwSetWindowOpacity');
  late final _glfwSetWindowOpacity = _glfwSetWindowOpacityPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, double)>();

  /// ! @brief Iconifies the specified window.
  ///
  /// This function iconifies (minimizes) the specified window if it was
  /// previously restored.  If the window is already iconified, this function does
  /// nothing.
  ///
  /// If the specified window is a full screen window, the original monitor
  /// resolution is restored until the window is restored.
  ///
  /// @param[in] window The window to iconify.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland There is no concept of iconification in wl_shell, this
  /// function will emit @ref GLFW_PLATFORM_ERROR when using this deprecated
  /// protocol.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_iconify
  /// @sa @ref glfwRestoreWindow
  /// @sa @ref glfwMaximizeWindow
  ///
  /// @since Added in version 2.1.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwIconifyWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwIconifyWindow(
      window,
    );
  }

  late final _glfwIconifyWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwIconifyWindow');
  late final _glfwIconifyWindow = _glfwIconifyWindowPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Restores the specified window.
  ///
  /// This function restores the specified window if it was previously iconified
  /// (minimized) or maximized.  If the window is already restored, this function
  /// does nothing.
  ///
  /// If the specified window is a full screen window, the resolution chosen for
  /// the window is restored on the selected monitor.
  ///
  /// @param[in] window The window to restore.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_iconify
  /// @sa @ref glfwIconifyWindow
  /// @sa @ref glfwMaximizeWindow
  ///
  /// @since Added in version 2.1.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwRestoreWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwRestoreWindow(
      window,
    );
  }

  late final _glfwRestoreWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwRestoreWindow');
  late final _glfwRestoreWindow = _glfwRestoreWindowPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Maximizes the specified window.
  ///
  /// This function maximizes the specified window if it was previously not
  /// maximized.  If the window is already maximized, this function does nothing.
  ///
  /// If the specified window is a full screen window, this function does nothing.
  ///
  /// @param[in] window The window to maximize.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @par Thread Safety
  /// This function may only be called from the main thread.
  ///
  /// @sa @ref window_iconify
  /// @sa @ref glfwIconifyWindow
  /// @sa @ref glfwRestoreWindow
  ///
  /// @since Added in GLFW 3.2.
  ///
  /// @ingroup window
  void glfwMaximizeWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwMaximizeWindow(
      window,
    );
  }

  late final _glfwMaximizeWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwMaximizeWindow');
  late final _glfwMaximizeWindow = _glfwMaximizeWindowPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Makes the specified window visible.
  ///
  /// This function makes the specified window visible if it was previously
  /// hidden.  If the window is already visible or is in full screen mode, this
  /// function does nothing.
  ///
  /// By default, windowed mode windows are focused when shown
  /// Set the [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) window hint
  /// to change this behavior for all newly created windows, or change the
  /// behavior for an existing window with @ref glfwSetWindowAttrib.
  ///
  /// @param[in] window The window to make visible.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_hide
  /// @sa @ref glfwHideWindow
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwShowWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwShowWindow(
      window,
    );
  }

  late final _glfwShowWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwShowWindow');
  late final _glfwShowWindow =
      _glfwShowWindowPtr.asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Hides the specified window.
  ///
  /// This function hides the specified window if it was previously visible.  If
  /// the window is already hidden or is in full screen mode, this function does
  /// nothing.
  ///
  /// @param[in] window The window to hide.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_hide
  /// @sa @ref glfwShowWindow
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwHideWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwHideWindow(
      window,
    );
  }

  late final _glfwHideWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwHideWindow');
  late final _glfwHideWindow =
      _glfwHideWindowPtr.asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Brings the specified window to front and sets input focus.
  ///
  /// This function brings the specified window to front and sets input focus.
  /// The window should already be visible and not iconified.
  ///
  /// By default, both windowed and full screen mode windows are focused when
  /// initially created.  Set the [GLFW_FOCUSED](@ref GLFW_FOCUSED_hint) to
  /// disable this behavior.
  ///
  /// Also by default, windowed mode windows are focused when shown
  /// with @ref glfwShowWindow. Set the
  /// [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) to disable this behavior.
  ///
  /// __Do not use this function__ to steal focus from other applications unless
  /// you are certain that is what the user wants.  Focus stealing can be
  /// extremely disruptive.
  ///
  /// For a less disruptive way of getting the user's attention, see
  /// [attention requests](@ref window_attention).
  ///
  /// @param[in] window The window to give input focus.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland It is not possible for an application to bring its windows
  /// to front, this function will always emit @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_focus
  /// @sa @ref window_attention
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwFocusWindow(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwFocusWindow(
      window,
    );
  }

  late final _glfwFocusWindowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwFocusWindow');
  late final _glfwFocusWindow =
      _glfwFocusWindowPtr.asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Requests user attention to the specified window.
  ///
  /// This function requests user attention to the specified window.  On
  /// platforms where this is not supported, attention is requested to the
  /// application as a whole.
  ///
  /// Once the user has given attention, usually by focusing the window or
  /// application, the system will end the request automatically.
  ///
  /// @param[in] window The window to request attention to.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @macos Attention is requested to the application as a whole, not the
  /// specific window.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_attention
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  void glfwRequestWindowAttention(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwRequestWindowAttention(
      window,
    );
  }

  late final _glfwRequestWindowAttentionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwRequestWindowAttention');
  late final _glfwRequestWindowAttention = _glfwRequestWindowAttentionPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Returns the monitor that the window uses for full screen mode.
  ///
  /// This function returns the handle of the monitor that the specified window is
  /// in full screen on.
  ///
  /// @param[in] window The window to query.
  /// @return The monitor, or `NULL` if the window is in windowed mode or an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_monitor
  /// @sa @ref glfwSetWindowMonitor
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  ffi.Pointer<GLFWmonitor> glfwGetWindowMonitor(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwGetWindowMonitor(
      window,
    );
  }

  late final _glfwGetWindowMonitorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWmonitor> Function(
              ffi.Pointer<GLFWwindow>)>>('glfwGetWindowMonitor');
  late final _glfwGetWindowMonitor = _glfwGetWindowMonitorPtr
      .asFunction<ffi.Pointer<GLFWmonitor> Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Sets the mode, monitor, video mode and placement of a window.
  ///
  /// This function sets the monitor that the window uses for full screen mode or,
  /// if the monitor is `NULL`, makes it windowed mode.
  ///
  /// When setting a monitor, this function updates the width, height and refresh
  /// rate of the desired video mode and switches to the video mode closest to it.
  /// The window position is ignored when setting a monitor.
  ///
  /// When the monitor is `NULL`, the position, width and height are used to
  /// place the window content area.  The refresh rate is ignored when no monitor
  /// is specified.
  ///
  /// If you only wish to update the resolution of a full screen window or the
  /// size of a windowed mode window, see @ref glfwSetWindowSize.
  ///
  /// When a window transitions from full screen to windowed mode, this function
  /// restores any previous window settings such as whether it is decorated,
  /// floating, resizable, has size or aspect ratio limits, etc.
  ///
  /// @param[in] window The window whose monitor, size or video mode to set.
  /// @param[in] monitor The desired monitor, or `NULL` to set windowed mode.
  /// @param[in] xpos The desired x-coordinate of the upper-left corner of the
  /// content area.
  /// @param[in] ypos The desired y-coordinate of the upper-left corner of the
  /// content area.
  /// @param[in] width The desired with, in screen coordinates, of the content
  /// area or video mode.
  /// @param[in] height The desired height, in screen coordinates, of the content
  /// area or video mode.
  /// @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,
  /// or `GLFW_DONT_CARE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise
  /// affected by any resizing or mode switching, although you may need to update
  /// your viewport if the framebuffer size has changed.
  ///
  /// @remark @wayland The desired window position is ignored, as there is no way
  /// for an application to set this property.
  ///
  /// @remark @wayland Setting the window to full screen will not attempt to
  /// change the mode, no matter what the requested size or refresh rate.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_monitor
  /// @sa @ref window_full_screen
  /// @sa @ref glfwGetWindowMonitor
  /// @sa @ref glfwSetWindowSize
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwSetWindowMonitor(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<GLFWmonitor> monitor,
    int xpos,
    int ypos,
    int width,
    int height,
    int refreshRate,
  ) {
    return _glfwSetWindowMonitor(
      window,
      monitor,
      xpos,
      ypos,
      width,
      height,
      refreshRate,
    );
  }

  late final _glfwSetWindowMonitorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLFWwindow>,
              ffi.Pointer<GLFWmonitor>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('glfwSetWindowMonitor');
  late final _glfwSetWindowMonitor = _glfwSetWindowMonitorPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<GLFWmonitor>, int, int,
          int, int, int)>();

  /// ! @brief Returns an attribute of the specified window.
  ///
  /// This function returns the value of an attribute of the specified window or
  /// its OpenGL or OpenGL ES context.
  ///
  /// @param[in] window The window to query.
  /// @param[in] attrib The [window attribute](@ref window_attribs) whose value to
  /// return.
  /// @return The value of the attribute, or zero if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark Framebuffer related hints are not window attributes.  See @ref
  /// window_attribs_fb for more information.
  ///
  /// @remark Zero is a valid value for many window and context related
  /// attributes so you cannot use a return value of zero as an indication of
  /// errors.  However, this function should not fail as long as it is passed
  /// valid arguments and the library has been [initialized](@ref intro_init).
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_attribs
  /// @sa @ref glfwSetWindowAttrib
  ///
  /// @since Added in version 3.0.  Replaces `glfwGetWindowParam` and
  /// `glfwGetGLVersion`.
  ///
  /// @ingroup window
  int glfwGetWindowAttrib(
    ffi.Pointer<GLFWwindow> window,
    int attrib,
  ) {
    return _glfwGetWindowAttrib(
      window,
      attrib,
    );
  }

  late final _glfwGetWindowAttribPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GLFWwindow>, ffi.Int32)>>('glfwGetWindowAttrib');
  late final _glfwGetWindowAttrib = _glfwGetWindowAttribPtr
      .asFunction<int Function(ffi.Pointer<GLFWwindow>, int)>();

  /// ! @brief Sets an attribute of the specified window.
  ///
  /// This function sets the value of an attribute of the specified window.
  ///
  /// The supported attributes are [GLFW_DECORATED](@ref GLFW_DECORATED_attrib),
  /// [GLFW_RESIZABLE](@ref GLFW_RESIZABLE_attrib),
  /// [GLFW_FLOATING](@ref GLFW_FLOATING_attrib),
  /// [GLFW_AUTO_ICONIFY](@ref GLFW_AUTO_ICONIFY_attrib) and
  /// [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_attrib).
  ///
  /// Some of these attributes are ignored for full screen windows.  The new
  /// value will take effect if the window is later made windowed.
  ///
  /// Some of these attributes are ignored for windowed mode windows.  The new
  /// value will take effect if the window is later made full screen.
  ///
  /// @param[in] window The window to set the attribute for.
  /// @param[in] attrib A supported window attribute.
  /// @param[in] value `GLFW_TRUE` or `GLFW_FALSE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark Calling @ref glfwGetWindowAttrib will always return the latest
  /// value, even if that value is ignored by the current mode of the window.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_attribs
  /// @sa @ref glfwGetWindowAttrib
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  void glfwSetWindowAttrib(
    ffi.Pointer<GLFWwindow> window,
    int attrib,
    int value,
  ) {
    return _glfwSetWindowAttrib(
      window,
      attrib,
      value,
    );
  }

  late final _glfwSetWindowAttribPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Int32)>>('glfwSetWindowAttrib');
  late final _glfwSetWindowAttrib = _glfwSetWindowAttribPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int)>();

  /// ! @brief Sets the user pointer of the specified window.
  ///
  /// This function sets the user-defined pointer of the specified window.  The
  /// current value is retained until the window is destroyed.  The initial value
  /// is `NULL`.
  ///
  /// @param[in] window The window whose pointer to set.
  /// @param[in] pointer The new value.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref window_userptr
  /// @sa @ref glfwGetWindowUserPointer
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  void glfwSetWindowUserPointer(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Void> pointer,
  ) {
    return _glfwSetWindowUserPointer(
      window,
      pointer,
    );
  }

  late final _glfwSetWindowUserPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>,
              ffi.Pointer<ffi.Void>)>>('glfwSetWindowUserPointer');
  late final _glfwSetWindowUserPointer =
      _glfwSetWindowUserPointerPtr.asFunction<
          void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Void>)>();

  /// ! @brief Returns the user pointer of the specified window.
  ///
  /// This function returns the current value of the user-defined pointer of the
  /// specified window.  The initial value is `NULL`.
  ///
  /// @param[in] window The window whose pointer to return.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref window_userptr
  /// @sa @ref glfwSetWindowUserPointer
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  ffi.Pointer<ffi.Void> glfwGetWindowUserPointer(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwGetWindowUserPointer(
      window,
    );
  }

  late final _glfwGetWindowUserPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GLFWwindow>)>>('glfwGetWindowUserPointer');
  late final _glfwGetWindowUserPointer = _glfwGetWindowUserPointerPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Sets the position callback for the specified window.
  ///
  /// This function sets the position callback of the specified window, which is
  /// called when the window is moved.  The callback is provided with the
  /// position, in screen coordinates, of the upper-left corner of the content
  /// area of the window.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int xpos, int ypos)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowposfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @remark @wayland This callback will never be called, as there is no way for
  /// an application to know its global position.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_pos
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  GLFWwindowposfun glfwSetWindowPosCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowposfun callback,
  ) {
    return _glfwSetWindowPosCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowPosCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowposfun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowposfun)>>('glfwSetWindowPosCallback');
  late final _glfwSetWindowPosCallback =
      _glfwSetWindowPosCallbackPtr.asFunction<
          GLFWwindowposfun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowposfun)>();

  /// ! @brief Sets the size callback for the specified window.
  ///
  /// This function sets the size callback of the specified window, which is
  /// called when the window is resized.  The callback is provided with the size,
  /// in screen coordinates, of the content area of the window.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int width, int height)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowsizefun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_size
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup window
  GLFWwindowsizefun glfwSetWindowSizeCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowsizefun callback,
  ) {
    return _glfwSetWindowSizeCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowSizeCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowsizefun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowsizefun)>>('glfwSetWindowSizeCallback');
  late final _glfwSetWindowSizeCallback =
      _glfwSetWindowSizeCallbackPtr.asFunction<
          GLFWwindowsizefun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowsizefun)>();

  /// ! @brief Sets the close callback for the specified window.
  ///
  /// This function sets the close callback of the specified window, which is
  /// called when the user attempts to close the window, for example by clicking
  /// the close widget in the title bar.
  ///
  /// The close flag is set before this callback is called, but you can modify it
  /// at any time with @ref glfwSetWindowShouldClose.
  ///
  /// The close callback is not triggered by @ref glfwDestroyWindow.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowclosefun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @remark @macos Selecting Quit from the application menu will trigger the
  /// close callback for all windows.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_close
  ///
  /// @since Added in version 2.5.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup window
  GLFWwindowclosefun glfwSetWindowCloseCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowclosefun callback,
  ) {
    return _glfwSetWindowCloseCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowCloseCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowclosefun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowclosefun)>>('glfwSetWindowCloseCallback');
  late final _glfwSetWindowCloseCallback =
      _glfwSetWindowCloseCallbackPtr.asFunction<
          GLFWwindowclosefun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowclosefun)>();

  /// ! @brief Sets the refresh callback for the specified window.
  ///
  /// This function sets the refresh callback of the specified window, which is
  /// called when the content area of the window needs to be redrawn, for example
  /// if the window has been exposed after having been covered by another window.
  ///
  /// On compositing window systems such as Aero, Compiz, Aqua or Wayland, where
  /// the window contents are saved off-screen, this callback may be called only
  /// very infrequently or never at all.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window);
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowrefreshfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_refresh
  ///
  /// @since Added in version 2.5.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup window
  GLFWwindowrefreshfun glfwSetWindowRefreshCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowrefreshfun callback,
  ) {
    return _glfwSetWindowRefreshCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowRefreshCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowrefreshfun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowrefreshfun)>>('glfwSetWindowRefreshCallback');
  late final _glfwSetWindowRefreshCallback =
      _glfwSetWindowRefreshCallbackPtr.asFunction<
          GLFWwindowrefreshfun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowrefreshfun)>();

  /// ! @brief Sets the focus callback for the specified window.
  ///
  /// This function sets the focus callback of the specified window, which is
  /// called when the window gains or loses input focus.
  ///
  /// After the focus callback is called for a window that lost input focus,
  /// synthetic key and mouse button release events will be generated for all such
  /// that had been pressed.  For more information, see @ref glfwSetKeyCallback
  /// and @ref glfwSetMouseButtonCallback.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int focused)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowfocusfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_focus
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  GLFWwindowfocusfun glfwSetWindowFocusCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowfocusfun callback,
  ) {
    return _glfwSetWindowFocusCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowFocusCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowfocusfun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowfocusfun)>>('glfwSetWindowFocusCallback');
  late final _glfwSetWindowFocusCallback =
      _glfwSetWindowFocusCallbackPtr.asFunction<
          GLFWwindowfocusfun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowfocusfun)>();

  /// ! @brief Sets the iconify callback for the specified window.
  ///
  /// This function sets the iconification callback of the specified window, which
  /// is called when the window is iconified or restored.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int iconified)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowiconifyfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @remark @wayland The wl_shell protocol has no concept of iconification,
  /// this callback will never be called when using this deprecated protocol.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_iconify
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  GLFWwindowiconifyfun glfwSetWindowIconifyCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowiconifyfun callback,
  ) {
    return _glfwSetWindowIconifyCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowIconifyCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowiconifyfun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowiconifyfun)>>('glfwSetWindowIconifyCallback');
  late final _glfwSetWindowIconifyCallback =
      _glfwSetWindowIconifyCallbackPtr.asFunction<
          GLFWwindowiconifyfun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowiconifyfun)>();

  /// ! @brief Sets the maximize callback for the specified window.
  ///
  /// This function sets the maximization callback of the specified window, which
  /// is called when the window is maximized or restored.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int maximized)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowmaximizefun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_maximize
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowmaximizefun callback,
  ) {
    return _glfwSetWindowMaximizeCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowMaximizeCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowmaximizefun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowmaximizefun)>>('glfwSetWindowMaximizeCallback');
  late final _glfwSetWindowMaximizeCallback =
      _glfwSetWindowMaximizeCallbackPtr.asFunction<
          GLFWwindowmaximizefun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowmaximizefun)>();

  /// ! @brief Sets the framebuffer resize callback for the specified window.
  ///
  /// This function sets the framebuffer resize callback of the specified window,
  /// which is called when the framebuffer of the specified window is resized.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int width, int height)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWframebuffersizefun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_fbsize
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup window
  GLFWframebuffersizefun glfwSetFramebufferSizeCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWframebuffersizefun callback,
  ) {
    return _glfwSetFramebufferSizeCallback(
      window,
      callback,
    );
  }

  late final _glfwSetFramebufferSizeCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWframebuffersizefun Function(ffi.Pointer<GLFWwindow>,
              GLFWframebuffersizefun)>>('glfwSetFramebufferSizeCallback');
  late final _glfwSetFramebufferSizeCallback =
      _glfwSetFramebufferSizeCallbackPtr.asFunction<
          GLFWframebuffersizefun Function(
              ffi.Pointer<GLFWwindow>, GLFWframebuffersizefun)>();

  /// ! @brief Sets the window content scale callback for the specified window.
  ///
  /// This function sets the window content scale callback of the specified window,
  /// which is called when the content scale of the specified window changes.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, float xscale, float yscale)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWwindowcontentscalefun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref window_scale
  /// @sa @ref glfwGetWindowContentScale
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup window
  GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWwindowcontentscalefun callback,
  ) {
    return _glfwSetWindowContentScaleCallback(
      window,
      callback,
    );
  }

  late final _glfwSetWindowContentScaleCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWwindowcontentscalefun Function(ffi.Pointer<GLFWwindow>,
              GLFWwindowcontentscalefun)>>('glfwSetWindowContentScaleCallback');
  late final _glfwSetWindowContentScaleCallback =
      _glfwSetWindowContentScaleCallbackPtr.asFunction<
          GLFWwindowcontentscalefun Function(
              ffi.Pointer<GLFWwindow>, GLFWwindowcontentscalefun)>();

  /// ! @brief Processes all pending events.
  ///
  /// This function processes only those events that are already in the event
  /// queue and then returns immediately.  Processing events will cause the window
  /// and input callbacks associated with those events to be called.
  ///
  /// On some platforms, a window move, resize or menu operation will cause event
  /// processing to block.  This is due to how event processing is designed on
  /// those platforms.  You can use the
  /// [window refresh callback](@ref window_refresh) to redraw the contents of
  /// your window when necessary during such operations.
  ///
  /// Do not assume that callbacks you set will _only_ be called in response to
  /// event processing functions like this one.  While it is necessary to poll for
  /// events, window systems that require GLFW to register callbacks of its own
  /// can pass events to GLFW in response to many window system function calls.
  /// GLFW will pass those events on to the application callbacks before
  /// returning.
  ///
  /// Event processing is not required for joystick input to work.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref events
  /// @sa @ref glfwWaitEvents
  /// @sa @ref glfwWaitEventsTimeout
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup window
  void glfwPollEvents() {
    return _glfwPollEvents();
  }

  late final _glfwPollEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glfwPollEvents');
  late final _glfwPollEvents = _glfwPollEventsPtr.asFunction<void Function()>();

  /// ! @brief Waits until events are queued and processes them.
  ///
  /// This function puts the calling thread to sleep until at least one event is
  /// available in the event queue.  Once one or more events are available,
  /// it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue
  /// are processed and the function then returns immediately.  Processing events
  /// will cause the window and input callbacks associated with those events to be
  /// called.
  ///
  /// Since not all events are associated with callbacks, this function may return
  /// without a callback having been called even if you are monitoring all
  /// callbacks.
  ///
  /// On some platforms, a window move, resize or menu operation will cause event
  /// processing to block.  This is due to how event processing is designed on
  /// those platforms.  You can use the
  /// [window refresh callback](@ref window_refresh) to redraw the contents of
  /// your window when necessary during such operations.
  ///
  /// Do not assume that callbacks you set will _only_ be called in response to
  /// event processing functions like this one.  While it is necessary to poll for
  /// events, window systems that require GLFW to register callbacks of its own
  /// can pass events to GLFW in response to many window system function calls.
  /// GLFW will pass those events on to the application callbacks before
  /// returning.
  ///
  /// Event processing is not required for joystick input to work.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref events
  /// @sa @ref glfwPollEvents
  /// @sa @ref glfwWaitEventsTimeout
  ///
  /// @since Added in version 2.5.
  ///
  /// @ingroup window
  void glfwWaitEvents() {
    return _glfwWaitEvents();
  }

  late final _glfwWaitEventsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glfwWaitEvents');
  late final _glfwWaitEvents = _glfwWaitEventsPtr.asFunction<void Function()>();

  /// ! @brief Waits with timeout until events are queued and processes them.
  ///
  /// This function puts the calling thread to sleep until at least one event is
  /// available in the event queue, or until the specified timeout is reached.  If
  /// one or more events are available, it behaves exactly like @ref
  /// glfwPollEvents, i.e. the events in the queue are processed and the function
  /// then returns immediately.  Processing events will cause the window and input
  /// callbacks associated with those events to be called.
  ///
  /// The timeout value must be a positive finite number.
  ///
  /// Since not all events are associated with callbacks, this function may return
  /// without a callback having been called even if you are monitoring all
  /// callbacks.
  ///
  /// On some platforms, a window move, resize or menu operation will cause event
  /// processing to block.  This is due to how event processing is designed on
  /// those platforms.  You can use the
  /// [window refresh callback](@ref window_refresh) to redraw the contents of
  /// your window when necessary during such operations.
  ///
  /// Do not assume that callbacks you set will _only_ be called in response to
  /// event processing functions like this one.  While it is necessary to poll for
  /// events, window systems that require GLFW to register callbacks of its own
  /// can pass events to GLFW in response to many window system function calls.
  /// GLFW will pass those events on to the application callbacks before
  /// returning.
  ///
  /// Event processing is not required for joystick input to work.
  ///
  /// @param[in] timeout The maximum amount of time, in seconds, to wait.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref events
  /// @sa @ref glfwPollEvents
  /// @sa @ref glfwWaitEvents
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup window
  void glfwWaitEventsTimeout(
    double timeout,
  ) {
    return _glfwWaitEventsTimeout(
      timeout,
    );
  }

  late final _glfwWaitEventsTimeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Double)>>(
          'glfwWaitEventsTimeout');
  late final _glfwWaitEventsTimeout =
      _glfwWaitEventsTimeoutPtr.asFunction<void Function(double)>();

  /// ! @brief Posts an empty event to the event queue.
  ///
  /// This function posts an empty event from the current thread to the event
  /// queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref events
  /// @sa @ref glfwWaitEvents
  /// @sa @ref glfwWaitEventsTimeout
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup window
  void glfwPostEmptyEvent() {
    return _glfwPostEmptyEvent();
  }

  late final _glfwPostEmptyEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('glfwPostEmptyEvent');
  late final _glfwPostEmptyEvent =
      _glfwPostEmptyEventPtr.asFunction<void Function()>();

  /// ! @brief Returns the value of an input option for the specified window.
  ///
  /// This function returns the value of an input option for the specified window.
  /// The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
  /// @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
  /// @ref GLFW_RAW_MOUSE_MOTION.
  ///
  /// @param[in] window The window to query.
  /// @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
  /// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
  /// `GLFW_RAW_MOUSE_MOTION`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref glfwSetInputMode
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup input
  int glfwGetInputMode(
    ffi.Pointer<GLFWwindow> window,
    int mode,
  ) {
    return _glfwGetInputMode(
      window,
      mode,
    );
  }

  late final _glfwGetInputModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GLFWwindow>, ffi.Int32)>>('glfwGetInputMode');
  late final _glfwGetInputMode = _glfwGetInputModePtr
      .asFunction<int Function(ffi.Pointer<GLFWwindow>, int)>();

  /// ! @brief Sets an input option for the specified window.
  ///
  /// This function sets an input mode option for the specified window.  The mode
  /// must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
  /// @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
  /// @ref GLFW_RAW_MOUSE_MOTION.
  ///
  /// If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
  /// modes:
  /// - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
  /// - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the
  /// content area of the window but does not restrict the cursor from leaving.
  /// - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
  /// and unlimited cursor movement.  This is useful for implementing for
  /// example 3D camera controls.
  ///
  /// If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
  /// enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
  /// enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`
  /// the next time it is called even if the key had been released before the
  /// call.  This is useful when you are only interested in whether keys have been
  /// pressed but not when or in which order.
  ///
  /// If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
  /// `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
  /// If sticky mouse buttons are enabled, a mouse button press will ensure that
  /// @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even
  /// if the mouse button had been released before the call.  This is useful when
  /// you are only interested in whether mouse buttons have been pressed but not
  /// when or in which order.
  ///
  /// If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to
  /// enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,
  /// callbacks that receive modifier bits will also have the @ref
  /// GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on,
  /// and the @ref GLFW_MOD_NUM_LOCK bit when Num Lock was on.
  ///
  /// If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`
  /// to enable raw (unscaled and unaccelerated) mouse motion when the cursor is
  /// disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,
  /// attempting to set this will emit @ref GLFW_PLATFORM_ERROR.  Call @ref
  /// glfwRawMouseMotionSupported to check for support.
  ///
  /// @param[in] window The window whose input mode to set.
  /// @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
  /// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
  /// `GLFW_RAW_MOUSE_MOTION`.
  /// @param[in] value The new value of the specified input mode.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref glfwGetInputMode
  ///
  /// @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.
  ///
  /// @ingroup input
  void glfwSetInputMode(
    ffi.Pointer<GLFWwindow> window,
    int mode,
    int value,
  ) {
    return _glfwSetInputMode(
      window,
      mode,
      value,
    );
  }

  late final _glfwSetInputModePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
              ffi.Int32)>>('glfwSetInputMode');
  late final _glfwSetInputMode = _glfwSetInputModePtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, int, int)>();

  /// ! @brief Returns whether raw mouse motion is supported.
  ///
  /// This function returns whether raw mouse motion is supported on the current
  /// system.  This status does not change after GLFW has been initialized so you
  /// only need to check this once.  If you attempt to enable raw motion on
  /// a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted.
  ///
  /// Raw mouse motion is closer to the actual motion of the mouse across
  /// a surface.  It is not affected by the scaling and acceleration applied to
  /// the motion of the desktop cursor.  That processing is suitable for a cursor
  /// while raw motion is better for controlling for example a 3D camera.  Because
  /// of this, raw mouse motion is only provided when the cursor is disabled.
  ///
  /// @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,
  /// or `GLFW_FALSE` otherwise.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref raw_mouse_motion
  /// @sa @ref glfwSetInputMode
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  int glfwRawMouseMotionSupported() {
    return _glfwRawMouseMotionSupported();
  }

  late final _glfwRawMouseMotionSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'glfwRawMouseMotionSupported');
  late final _glfwRawMouseMotionSupported =
      _glfwRawMouseMotionSupportedPtr.asFunction<int Function()>();

  /// ! @brief Returns the layout-specific name of the specified printable key.
  ///
  /// This function returns the name of the specified printable key, encoded as
  /// UTF-8.  This is typically the character that key would produce without any
  /// modifier keys, intended for displaying key bindings to the user.  For dead
  /// keys, it is typically the diacritic it would add to a character.
  ///
  /// __Do not use this function__ for [text input](@ref input_char).  You will
  /// break text input for many languages even if it happens to work for yours.
  ///
  /// If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,
  /// otherwise the scancode is ignored.  If you specify a non-printable key, or
  /// `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this
  /// function returns `NULL` but does not emit an error.
  ///
  /// This behavior allows you to always pass in the arguments in the
  /// [key callback](@ref input_key) without modification.
  ///
  /// The printable keys are:
  /// - `GLFW_KEY_APOSTROPHE`
  /// - `GLFW_KEY_COMMA`
  /// - `GLFW_KEY_MINUS`
  /// - `GLFW_KEY_PERIOD`
  /// - `GLFW_KEY_SLASH`
  /// - `GLFW_KEY_SEMICOLON`
  /// - `GLFW_KEY_EQUAL`
  /// - `GLFW_KEY_LEFT_BRACKET`
  /// - `GLFW_KEY_RIGHT_BRACKET`
  /// - `GLFW_KEY_BACKSLASH`
  /// - `GLFW_KEY_WORLD_1`
  /// - `GLFW_KEY_WORLD_2`
  /// - `GLFW_KEY_0` to `GLFW_KEY_9`
  /// - `GLFW_KEY_A` to `GLFW_KEY_Z`
  /// - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
  /// - `GLFW_KEY_KP_DECIMAL`
  /// - `GLFW_KEY_KP_DIVIDE`
  /// - `GLFW_KEY_KP_MULTIPLY`
  /// - `GLFW_KEY_KP_SUBTRACT`
  /// - `GLFW_KEY_KP_ADD`
  /// - `GLFW_KEY_KP_EQUAL`
  ///
  /// Names for printable keys depend on keyboard layout, while names for
  /// non-printable keys are the same across layouts but depend on the application
  /// language and should be localized along with other user interface text.
  ///
  /// @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`.
  /// @param[in] scancode The scancode of the key to query.
  /// @return The UTF-8 encoded, layout-specific name of the key, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark The contents of the returned string may change when a keyboard
  /// layout change event is received.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_key_name
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Int8> glfwGetKeyName(
    int key,
    int scancode,
  ) {
    return _glfwGetKeyName(
      key,
      scancode,
    );
  }

  late final _glfwGetKeyNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Int32, ffi.Int32)>>('glfwGetKeyName');
  late final _glfwGetKeyName =
      _glfwGetKeyNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int, int)>();

  /// ! @brief Returns the platform-specific scancode of the specified key.
  ///
  /// This function returns the platform-specific scancode of the specified key.
  ///
  /// If the key is `GLFW_KEY_UNKNOWN` or does not exist on the keyboard this
  /// method will return `-1`.
  ///
  /// @param[in] key Any [named key](@ref keys).
  /// @return The platform-specific scancode for the key, or `-1` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref input_key
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  int glfwGetKeyScancode(
    int key,
  ) {
    return _glfwGetKeyScancode(
      key,
    );
  }

  late final _glfwGetKeyScancodePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'glfwGetKeyScancode');
  late final _glfwGetKeyScancode =
      _glfwGetKeyScancodePtr.asFunction<int Function(int)>();

  /// ! @brief Returns the last reported state of a keyboard key for the specified
  /// window.
  ///
  /// This function returns the last state reported for the specified key to the
  /// specified window.  The returned state is one of `GLFW_PRESS` or
  /// `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to
  /// the key callback.
  ///
  /// If the @ref GLFW_STICKY_KEYS input mode is enabled, this function returns
  /// `GLFW_PRESS` the first time you call it for a key that was pressed, even if
  /// that key has already been released.
  ///
  /// The key functions deal with physical keys, with [key tokens](@ref keys)
  /// named after their use on the standard US keyboard layout.  If you want to
  /// input text, use the Unicode character callback instead.
  ///
  /// The [modifier key bit masks](@ref mods) are not key tokens and cannot be
  /// used with this function.
  ///
  /// __Do not use this function__ to implement [text input](@ref input_char).
  ///
  /// @param[in] window The desired window.
  /// @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is
  /// not a valid key for this function.
  /// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_key
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup input
  int glfwGetKey(
    ffi.Pointer<GLFWwindow> window,
    int key,
  ) {
    return _glfwGetKey(
      window,
      key,
    );
  }

  late final _glfwGetKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GLFWwindow>, ffi.Int32)>>('glfwGetKey');
  late final _glfwGetKey =
      _glfwGetKeyPtr.asFunction<int Function(ffi.Pointer<GLFWwindow>, int)>();

  /// ! @brief Returns the last reported state of a mouse button for the specified
  /// window.
  ///
  /// This function returns the last state reported for the specified mouse button
  /// to the specified window.  The returned state is one of `GLFW_PRESS` or
  /// `GLFW_RELEASE`.
  ///
  /// If the @ref GLFW_STICKY_MOUSE_BUTTONS input mode is enabled, this function
  /// returns `GLFW_PRESS` the first time you call it for a mouse button that was
  /// pressed, even if that mouse button has already been released.
  ///
  /// @param[in] window The desired window.
  /// @param[in] button The desired [mouse button](@ref buttons).
  /// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_mouse_button
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup input
  int glfwGetMouseButton(
    ffi.Pointer<GLFWwindow> window,
    int button,
  ) {
    return _glfwGetMouseButton(
      window,
      button,
    );
  }

  late final _glfwGetMouseButtonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GLFWwindow>, ffi.Int32)>>('glfwGetMouseButton');
  late final _glfwGetMouseButton = _glfwGetMouseButtonPtr
      .asFunction<int Function(ffi.Pointer<GLFWwindow>, int)>();

  /// ! @brief Retrieves the position of the cursor relative to the content area of
  /// the window.
  ///
  /// This function returns the position of the cursor, in screen coordinates,
  /// relative to the upper-left corner of the content area of the specified
  /// window.
  ///
  /// If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
  /// position is unbounded and limited only by the minimum and maximum values of
  /// a `double`.
  ///
  /// The coordinate can be converted to their integer equivalents with the
  /// `floor` function.  Casting directly to an integer type works for positive
  /// coordinates, but fails for negative ones.
  ///
  /// Any or all of the position arguments may be `NULL`.  If an error occurs, all
  /// non-`NULL` position arguments will be set to zero.
  ///
  /// @param[in] window The desired window.
  /// @param[out] xpos Where to store the cursor x-coordinate, relative to the
  /// left edge of the content area, or `NULL`.
  /// @param[out] ypos Where to store the cursor y-coordinate, relative to the to
  /// top edge of the content area, or `NULL`.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_pos
  /// @sa @ref glfwSetCursorPos
  ///
  /// @since Added in version 3.0.  Replaces `glfwGetMousePos`.
  ///
  /// @ingroup input
  void glfwGetCursorPos(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Double> xpos,
    ffi.Pointer<ffi.Double> ypos,
  ) {
    return _glfwGetCursorPos(
      window,
      xpos,
      ypos,
    );
  }

  late final _glfwGetCursorPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('glfwGetCursorPos');
  late final _glfwGetCursorPos = _glfwGetCursorPosPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// ! @brief Sets the position of the cursor, relative to the content area of the
  /// window.
  ///
  /// This function sets the position, in screen coordinates, of the cursor
  /// relative to the upper-left corner of the content area of the specified
  /// window.  The window must have input focus.  If the window does not have
  /// input focus when this function is called, it fails silently.
  ///
  /// __Do not use this function__ to implement things like camera controls.  GLFW
  /// already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
  /// cursor, transparently re-centers it and provides unconstrained cursor
  /// motion.  See @ref glfwSetInputMode for more information.
  ///
  /// If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
  /// unconstrained and limited only by the minimum and maximum values of
  /// a `double`.
  ///
  /// @param[in] window The desired window.
  /// @param[in] xpos The desired x-coordinate, relative to the left edge of the
  /// content area.
  /// @param[in] ypos The desired y-coordinate, relative to the top edge of the
  /// content area.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @remark @wayland This function will only work when the cursor mode is
  /// `GLFW_CURSOR_DISABLED`, otherwise it will do nothing.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_pos
  /// @sa @ref glfwGetCursorPos
  ///
  /// @since Added in version 3.0.  Replaces `glfwSetMousePos`.
  ///
  /// @ingroup input
  void glfwSetCursorPos(
    ffi.Pointer<GLFWwindow> window,
    double xpos,
    double ypos,
  ) {
    return _glfwSetCursorPos(
      window,
      xpos,
      ypos,
    );
  }

  late final _glfwSetCursorPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Double,
              ffi.Double)>>('glfwSetCursorPos');
  late final _glfwSetCursorPos = _glfwSetCursorPosPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>, double, double)>();

  /// ! @brief Creates a custom cursor.
  ///
  /// Creates a new custom cursor image that can be set for a window with @ref
  /// glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor.
  /// Any remaining cursors are destroyed by @ref glfwTerminate.
  ///
  /// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
  /// bits per channel with the red channel first.  They are arranged canonically
  /// as packed sequential rows, starting from the top-left corner.
  ///
  /// The cursor hotspot is specified in pixels, relative to the upper-left corner
  /// of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
  /// points to the right and the Y-axis points down.
  ///
  /// @param[in] image The desired cursor image.
  /// @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot.
  /// @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot.
  /// @return The handle of the created cursor, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The specified image data is copied before this function
  /// returns.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_object
  /// @sa @ref glfwDestroyCursor
  /// @sa @ref glfwCreateStandardCursor
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  ffi.Pointer<GLFWcursor> glfwCreateCursor(
    ffi.Pointer<GLFWimage> image,
    int xhot,
    int yhot,
  ) {
    return _glfwCreateCursor(
      image,
      xhot,
      yhot,
    );
  }

  late final _glfwCreateCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GLFWcursor> Function(ffi.Pointer<GLFWimage>, ffi.Int32,
              ffi.Int32)>>('glfwCreateCursor');
  late final _glfwCreateCursor = _glfwCreateCursorPtr.asFunction<
      ffi.Pointer<GLFWcursor> Function(ffi.Pointer<GLFWimage>, int, int)>();

  /// ! @brief Creates a cursor with a standard shape.
  ///
  /// Returns a cursor with a [standard shape](@ref shapes), that can be set for
  /// a window with @ref glfwSetCursor.
  ///
  /// @param[in] shape One of the [standard shapes](@ref shapes).
  /// @return A new cursor ready to use or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_object
  /// @sa @ref glfwCreateCursor
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  ffi.Pointer<GLFWcursor> glfwCreateStandardCursor(
    int shape,
  ) {
    return _glfwCreateStandardCursor(
      shape,
    );
  }

  late final _glfwCreateStandardCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GLFWcursor> Function(ffi.Int32)>>(
          'glfwCreateStandardCursor');
  late final _glfwCreateStandardCursor = _glfwCreateStandardCursorPtr
      .asFunction<ffi.Pointer<GLFWcursor> Function(int)>();

  /// ! @brief Destroys a cursor.
  ///
  /// This function destroys a cursor previously created with @ref
  /// glfwCreateCursor.  Any remaining cursors will be destroyed by @ref
  /// glfwTerminate.
  ///
  /// If the specified cursor is current for any window, that window will be
  /// reverted to the default cursor.  This does not affect the cursor mode.
  ///
  /// @param[in] cursor The cursor object to destroy.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @reentrancy This function must not be called from a callback.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_object
  /// @sa @ref glfwCreateCursor
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  void glfwDestroyCursor(
    ffi.Pointer<GLFWcursor> cursor,
  ) {
    return _glfwDestroyCursor(
      cursor,
    );
  }

  late final _glfwDestroyCursorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWcursor>)>>(
          'glfwDestroyCursor');
  late final _glfwDestroyCursor = _glfwDestroyCursorPtr
      .asFunction<void Function(ffi.Pointer<GLFWcursor>)>();

  /// ! @brief Sets the cursor for the window.
  ///
  /// This function sets the cursor image to be used when the cursor is over the
  /// content area of the specified window.  The set cursor will only be visible
  /// when the [cursor mode](@ref cursor_mode) of the window is
  /// `GLFW_CURSOR_NORMAL`.
  ///
  /// On some platforms, the set cursor may not be visible unless the window also
  /// has input focus.
  ///
  /// @param[in] window The window to set the cursor for.
  /// @param[in] cursor The cursor to set, or `NULL` to switch back to the default
  /// arrow cursor.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_object
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  void glfwSetCursor(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<GLFWcursor> cursor,
  ) {
    return _glfwSetCursor(
      window,
      cursor,
    );
  }

  late final _glfwSetCursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>,
              ffi.Pointer<GLFWcursor>)>>('glfwSetCursor');
  late final _glfwSetCursor = _glfwSetCursorPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<GLFWcursor>)>();

  /// ! @brief Sets the key callback.
  ///
  /// This function sets the key callback of the specified window, which is called
  /// when a key is pressed, repeated or released.
  ///
  /// The key functions deal with physical keys, with layout independent
  /// [key tokens](@ref keys) named after their values in the standard US keyboard
  /// layout.  If you want to input text, use the
  /// [character callback](@ref glfwSetCharCallback) instead.
  ///
  /// When a window loses input focus, it will generate synthetic key release
  /// events for all pressed keys.  You can tell these events from user-generated
  /// events by the fact that the synthetic ones are generated after the focus
  /// loss event has been processed, i.e. after the
  /// [window focus callback](@ref glfwSetWindowFocusCallback) has been called.
  ///
  /// The scancode of a key is specific to that platform or sometimes even to that
  /// machine.  Scancodes are intended to allow users to bind keys that don't have
  /// a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
  /// state is not saved and so it cannot be queried with @ref glfwGetKey.
  ///
  /// Sometimes GLFW needs to generate synthetic key events, in which case the
  /// scancode may be zero.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new key callback, or `NULL` to remove the currently
  /// set callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWkeyfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_key
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup input
  GLFWkeyfun glfwSetKeyCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWkeyfun callback,
  ) {
    return _glfwSetKeyCallback(
      window,
      callback,
    );
  }

  late final _glfwSetKeyCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWkeyfun Function(
              ffi.Pointer<GLFWwindow>, GLFWkeyfun)>>('glfwSetKeyCallback');
  late final _glfwSetKeyCallback = _glfwSetKeyCallbackPtr
      .asFunction<GLFWkeyfun Function(ffi.Pointer<GLFWwindow>, GLFWkeyfun)>();

  /// ! @brief Sets the Unicode character callback.
  ///
  /// This function sets the character callback of the specified window, which is
  /// called when a Unicode character is input.
  ///
  /// The character callback is intended for Unicode text input.  As it deals with
  /// characters, it is keyboard layout dependent, whereas the
  /// [key callback](@ref glfwSetKeyCallback) is not.  Characters do not map 1:1
  /// to physical keys, as a key may produce zero, one or more characters.  If you
  /// want to know whether a specific physical key was pressed or released, see
  /// the key callback instead.
  ///
  /// The character callback behaves as system text input normally does and will
  /// not be called if modifier keys are held down that would prevent normal text
  /// input on that platform, for example a Super (Command) key on macOS or Alt key
  /// on Windows.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, unsigned int codepoint)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWcharfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_char
  ///
  /// @since Added in version 2.4.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup input
  GLFWcharfun glfwSetCharCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWcharfun callback,
  ) {
    return _glfwSetCharCallback(
      window,
      callback,
    );
  }

  late final _glfwSetCharCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWcharfun Function(
              ffi.Pointer<GLFWwindow>, GLFWcharfun)>>('glfwSetCharCallback');
  late final _glfwSetCharCallback = _glfwSetCharCallbackPtr
      .asFunction<GLFWcharfun Function(ffi.Pointer<GLFWwindow>, GLFWcharfun)>();

  /// ! @brief Sets the Unicode character with modifiers callback.
  ///
  /// This function sets the character with modifiers callback of the specified
  /// window, which is called when a Unicode character is input regardless of what
  /// modifier keys are used.
  ///
  /// The character with modifiers callback is intended for implementing custom
  /// Unicode character input.  For regular Unicode text input, see the
  /// [character callback](@ref glfwSetCharCallback).  Like the character
  /// callback, the character with modifiers callback deals with characters and is
  /// keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
  /// a key may produce zero, one or more characters.  If you want to know whether
  /// a specific physical key was pressed or released, see the
  /// [key callback](@ref glfwSetKeyCallback) instead.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or an
  /// [error](@ref error_handling) occurred.
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, unsigned int codepoint, int mods)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWcharmodsfun).
  ///
  /// @deprecated Scheduled for removal in version 4.0.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_char
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  GLFWcharmodsfun glfwSetCharModsCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWcharmodsfun callback,
  ) {
    return _glfwSetCharModsCallback(
      window,
      callback,
    );
  }

  late final _glfwSetCharModsCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWcharmodsfun Function(ffi.Pointer<GLFWwindow>,
              GLFWcharmodsfun)>>('glfwSetCharModsCallback');
  late final _glfwSetCharModsCallback = _glfwSetCharModsCallbackPtr.asFunction<
      GLFWcharmodsfun Function(ffi.Pointer<GLFWwindow>, GLFWcharmodsfun)>();

  /// ! @brief Sets the mouse button callback.
  ///
  /// This function sets the mouse button callback of the specified window, which
  /// is called when a mouse button is pressed or released.
  ///
  /// When a window loses input focus, it will generate synthetic mouse button
  /// release events for all pressed mouse buttons.  You can tell these events
  /// from user-generated events by the fact that the synthetic ones are generated
  /// after the focus loss event has been processed, i.e. after the
  /// [window focus callback](@ref glfwSetWindowFocusCallback) has been called.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int button, int action, int mods)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWmousebuttonfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref input_mouse_button
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter and return value.
  ///
  /// @ingroup input
  GLFWmousebuttonfun glfwSetMouseButtonCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWmousebuttonfun callback,
  ) {
    return _glfwSetMouseButtonCallback(
      window,
      callback,
    );
  }

  late final _glfwSetMouseButtonCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWmousebuttonfun Function(ffi.Pointer<GLFWwindow>,
              GLFWmousebuttonfun)>>('glfwSetMouseButtonCallback');
  late final _glfwSetMouseButtonCallback =
      _glfwSetMouseButtonCallbackPtr.asFunction<
          GLFWmousebuttonfun Function(
              ffi.Pointer<GLFWwindow>, GLFWmousebuttonfun)>();

  /// ! @brief Sets the cursor position callback.
  ///
  /// This function sets the cursor position callback of the specified window,
  /// which is called when the cursor is moved.  The callback is provided with the
  /// position, in screen coordinates, relative to the upper-left corner of the
  /// content area of the window.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, double xpos, double ypos);
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWcursorposfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_pos
  ///
  /// @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`.
  ///
  /// @ingroup input
  GLFWcursorposfun glfwSetCursorPosCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWcursorposfun callback,
  ) {
    return _glfwSetCursorPosCallback(
      window,
      callback,
    );
  }

  late final _glfwSetCursorPosCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWcursorposfun Function(ffi.Pointer<GLFWwindow>,
              GLFWcursorposfun)>>('glfwSetCursorPosCallback');
  late final _glfwSetCursorPosCallback =
      _glfwSetCursorPosCallbackPtr.asFunction<
          GLFWcursorposfun Function(
              ffi.Pointer<GLFWwindow>, GLFWcursorposfun)>();

  /// ! @brief Sets the cursor enter/leave callback.
  ///
  /// This function sets the cursor boundary crossing callback of the specified
  /// window, which is called when the cursor enters or leaves the content area of
  /// the window.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int entered)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWcursorenterfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref cursor_enter
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup input
  GLFWcursorenterfun glfwSetCursorEnterCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWcursorenterfun callback,
  ) {
    return _glfwSetCursorEnterCallback(
      window,
      callback,
    );
  }

  late final _glfwSetCursorEnterCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWcursorenterfun Function(ffi.Pointer<GLFWwindow>,
              GLFWcursorenterfun)>>('glfwSetCursorEnterCallback');
  late final _glfwSetCursorEnterCallback =
      _glfwSetCursorEnterCallbackPtr.asFunction<
          GLFWcursorenterfun Function(
              ffi.Pointer<GLFWwindow>, GLFWcursorenterfun)>();

  /// ! @brief Sets the scroll callback.
  ///
  /// This function sets the scroll callback of the specified window, which is
  /// called when a scrolling device is used, such as a mouse wheel or scrolling
  /// area of a touchpad.
  ///
  /// The scroll callback receives all scrolling input, like that from a mouse
  /// wheel or a touchpad scrolling area.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new scroll callback, or `NULL` to remove the
  /// currently set callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, double xoffset, double yoffset)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWscrollfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref scrolling
  ///
  /// @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.
  ///
  /// @ingroup input
  GLFWscrollfun glfwSetScrollCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWscrollfun callback,
  ) {
    return _glfwSetScrollCallback(
      window,
      callback,
    );
  }

  late final _glfwSetScrollCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWscrollfun Function(ffi.Pointer<GLFWwindow>,
              GLFWscrollfun)>>('glfwSetScrollCallback');
  late final _glfwSetScrollCallback = _glfwSetScrollCallbackPtr.asFunction<
      GLFWscrollfun Function(ffi.Pointer<GLFWwindow>, GLFWscrollfun)>();

  /// ! @brief Sets the path drop callback.
  ///
  /// This function sets the path drop callback of the specified window, which is
  /// called when one or more dragged paths are dropped on the window.
  ///
  /// Because the path array and its strings may have been generated specifically
  /// for that event, they are not guaranteed to be valid after the callback has
  /// returned.  If you wish to use them after the callback returns, you need to
  /// make a deep copy.
  ///
  /// @param[in] window The window whose callback to set.
  /// @param[in] callback The new file drop callback, or `NULL` to remove the
  /// currently set callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(GLFWwindow* window, int path_count, const char* paths[])
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWdropfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @remark @wayland File drop is currently unimplemented.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref path_drop
  ///
  /// @since Added in version 3.1.
  ///
  /// @ingroup input
  GLFWdropfun glfwSetDropCallback(
    ffi.Pointer<GLFWwindow> window,
    GLFWdropfun callback,
  ) {
    return _glfwSetDropCallback(
      window,
      callback,
    );
  }

  late final _glfwSetDropCallbackPtr = _lookup<
      ffi.NativeFunction<
          GLFWdropfun Function(
              ffi.Pointer<GLFWwindow>, GLFWdropfun)>>('glfwSetDropCallback');
  late final _glfwSetDropCallback = _glfwSetDropCallbackPtr
      .asFunction<GLFWdropfun Function(ffi.Pointer<GLFWwindow>, GLFWdropfun)>();

  /// ! @brief Returns whether the specified joystick is present.
  ///
  /// This function returns whether the specified joystick is present.
  ///
  /// There is no need to call this function before other functions that accept
  /// a joystick ID, as they all check for presence before performing any other
  /// work.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick
  ///
  /// @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.
  ///
  /// @ingroup input
  int glfwJoystickPresent(
    int jid,
  ) {
    return _glfwJoystickPresent(
      jid,
    );
  }

  late final _glfwJoystickPresentPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'glfwJoystickPresent');
  late final _glfwJoystickPresent =
      _glfwJoystickPresentPtr.asFunction<int Function(int)>();

  /// ! @brief Returns the values of all axes of the specified joystick.
  ///
  /// This function returns the values of all axes of the specified joystick.
  /// Each element in the array is a value between -1.0 and 1.0.
  ///
  /// If the specified joystick is not present this function will return `NULL`
  /// but will not generate an error.  This can be used instead of first calling
  /// @ref glfwJoystickPresent.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @param[out] count Where to store the number of axis values in the returned
  /// array.  This is set to zero if the joystick is not present or an error
  /// occurred.
  /// @return An array of axis values, or `NULL` if the joystick is not present or
  /// an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick_axis
  ///
  /// @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Float> glfwGetJoystickAxes(
    int jid,
    ffi.Pointer<ffi.Int32> count,
  ) {
    return _glfwGetJoystickAxes(
      jid,
      count,
    );
  }

  late final _glfwGetJoystickAxesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Float> Function(
              ffi.Int32, ffi.Pointer<ffi.Int32>)>>('glfwGetJoystickAxes');
  late final _glfwGetJoystickAxes = _glfwGetJoystickAxesPtr.asFunction<
      ffi.Pointer<ffi.Float> Function(int, ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the state of all buttons of the specified joystick.
  ///
  /// This function returns the state of all buttons of the specified joystick.
  /// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
  ///
  /// For backward compatibility with earlier versions that did not have @ref
  /// glfwGetJoystickHats, the button array also includes all hats, each
  /// represented as four buttons.  The hats are in the same order as returned by
  /// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and
  /// _left_.  To disable these extra buttons, set the @ref
  /// GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization.
  ///
  /// If the specified joystick is not present this function will return `NULL`
  /// but will not generate an error.  This can be used instead of first calling
  /// @ref glfwJoystickPresent.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @param[out] count Where to store the number of button states in the returned
  /// array.  This is set to zero if the joystick is not present or an error
  /// occurred.
  /// @return An array of button states, or `NULL` if the joystick is not present
  /// or an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick_button
  ///
  /// @since Added in version 2.2.
  /// @glfw3 Changed to return a dynamic array.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Uint8> glfwGetJoystickButtons(
    int jid,
    ffi.Pointer<ffi.Int32> count,
  ) {
    return _glfwGetJoystickButtons(
      jid,
      count,
    );
  }

  late final _glfwGetJoystickButtonsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Int32, ffi.Pointer<ffi.Int32>)>>('glfwGetJoystickButtons');
  late final _glfwGetJoystickButtons = _glfwGetJoystickButtonsPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(int, ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the state of all hats of the specified joystick.
  ///
  /// This function returns the state of all hats of the specified joystick.
  /// Each element in the array is one of the following values:
  ///
  /// Name                  | Value
  /// ----                  | -----
  /// `GLFW_HAT_CENTERED`   | 0
  /// `GLFW_HAT_UP`         | 1
  /// `GLFW_HAT_RIGHT`      | 2
  /// `GLFW_HAT_DOWN`       | 4
  /// `GLFW_HAT_LEFT`       | 8
  /// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` \| `GLFW_HAT_UP`
  /// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` \| `GLFW_HAT_DOWN`
  /// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` \| `GLFW_HAT_UP`
  /// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` \| `GLFW_HAT_DOWN`
  ///
  /// The diagonal directions are bitwise combinations of the primary (up, right,
  /// down and left) directions and you can test for these individually by ANDing
  /// it with the corresponding direction.
  ///
  /// @code
  /// if (hats[2] & GLFW_HAT_RIGHT)
  /// {
  /// // State of hat 2 could be right-up, right or right-down
  /// }
  /// @endcode
  ///
  /// If the specified joystick is not present this function will return `NULL`
  /// but will not generate an error.  This can be used instead of first calling
  /// @ref glfwJoystickPresent.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @param[out] count Where to store the number of hat states in the returned
  /// array.  This is set to zero if the joystick is not present or an error
  /// occurred.
  /// @return An array of hat states, or `NULL` if the joystick is not present
  /// or an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected, this function is called again for that joystick or the library
  /// is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick_hat
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Uint8> glfwGetJoystickHats(
    int jid,
    ffi.Pointer<ffi.Int32> count,
  ) {
    return _glfwGetJoystickHats(
      jid,
      count,
    );
  }

  late final _glfwGetJoystickHatsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Int32, ffi.Pointer<ffi.Int32>)>>('glfwGetJoystickHats');
  late final _glfwGetJoystickHats = _glfwGetJoystickHatsPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(int, ffi.Pointer<ffi.Int32>)>();

  /// ! @brief Returns the name of the specified joystick.
  ///
  /// This function returns the name, encoded as UTF-8, of the specified joystick.
  /// The returned string is allocated and freed by GLFW.  You should not free it
  /// yourself.
  ///
  /// If the specified joystick is not present this function will return `NULL`
  /// but will not generate an error.  This can be used instead of first calling
  /// @ref glfwJoystickPresent.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick
  /// is not present or an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick_name
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Int8> glfwGetJoystickName(
    int jid,
  ) {
    return _glfwGetJoystickName(
      jid,
    );
  }

  late final _glfwGetJoystickNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'glfwGetJoystickName');
  late final _glfwGetJoystickName =
      _glfwGetJoystickNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// ! @brief Returns the SDL compatible GUID of the specified joystick.
  ///
  /// This function returns the SDL compatible GUID, as a UTF-8 encoded
  /// hexadecimal string, of the specified joystick.  The returned string is
  /// allocated and freed by GLFW.  You should not free it yourself.
  ///
  /// The GUID is what connects a joystick to a gamepad mapping.  A connected
  /// joystick will always have a GUID even if there is no gamepad mapping
  /// assigned to it.
  ///
  /// If the specified joystick is not present this function will return `NULL`
  /// but will not generate an error.  This can be used instead of first calling
  /// @ref glfwJoystickPresent.
  ///
  /// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to
  /// uniquely identify the make and model of a joystick but does not identify
  /// a specific unit, e.g. all wired Xbox 360 controllers will have the same
  /// GUID on that platform.  The GUID for a unit may vary between platforms
  /// depending on what hardware information the platform specific APIs provide.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick
  /// is not present or an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref gamepad
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Int8> glfwGetJoystickGUID(
    int jid,
  ) {
    return _glfwGetJoystickGUID(
      jid,
    );
  }

  late final _glfwGetJoystickGUIDPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'glfwGetJoystickGUID');
  late final _glfwGetJoystickGUID =
      _glfwGetJoystickGUIDPtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// ! @brief Sets the user pointer of the specified joystick.
  ///
  /// This function sets the user-defined pointer of the specified joystick.  The
  /// current value is retained until the joystick is disconnected.  The initial
  /// value is `NULL`.
  ///
  /// This function may be called from the joystick callback, even for a joystick
  /// that is being disconnected.
  ///
  /// @param[in] jid The joystick whose pointer to set.
  /// @param[in] pointer The new value.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref joystick_userptr
  /// @sa @ref glfwGetJoystickUserPointer
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  void glfwSetJoystickUserPointer(
    int jid,
    ffi.Pointer<ffi.Void> pointer,
  ) {
    return _glfwSetJoystickUserPointer(
      jid,
      pointer,
    );
  }

  late final _glfwSetJoystickUserPointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32, ffi.Pointer<ffi.Void>)>>('glfwSetJoystickUserPointer');
  late final _glfwSetJoystickUserPointer = _glfwSetJoystickUserPointerPtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Void>)>();

  /// ! @brief Returns the user pointer of the specified joystick.
  ///
  /// This function returns the current value of the user-defined pointer of the
  /// specified joystick.  The initial value is `NULL`.
  ///
  /// This function may be called from the joystick callback, even for a joystick
  /// that is being disconnected.
  ///
  /// @param[in] jid The joystick whose pointer to return.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Access is not
  /// synchronized.
  ///
  /// @sa @ref joystick_userptr
  /// @sa @ref glfwSetJoystickUserPointer
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Void> glfwGetJoystickUserPointer(
    int jid,
  ) {
    return _glfwGetJoystickUserPointer(
      jid,
    );
  }

  late final _glfwGetJoystickUserPointerPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
          'glfwGetJoystickUserPointer');
  late final _glfwGetJoystickUserPointer = _glfwGetJoystickUserPointerPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// ! @brief Returns whether the specified joystick has a gamepad mapping.
  ///
  /// This function returns whether the specified joystick is both present and has
  /// a gamepad mapping.
  ///
  /// If the specified joystick is present but does not have a gamepad mapping
  /// this function will return `GLFW_FALSE` but will not generate an error.  Call
  /// @ref glfwJoystickPresent to check if a joystick is present regardless of
  /// whether it has a mapping.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,
  /// or `GLFW_FALSE` otherwise.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref gamepad
  /// @sa @ref glfwGetGamepadState
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  int glfwJoystickIsGamepad(
    int jid,
  ) {
    return _glfwJoystickIsGamepad(
      jid,
    );
  }

  late final _glfwJoystickIsGamepadPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'glfwJoystickIsGamepad');
  late final _glfwJoystickIsGamepad =
      _glfwJoystickIsGamepadPtr.asFunction<int Function(int)>();

  /// ! @brief Sets the joystick configuration callback.
  ///
  /// This function sets the joystick configuration callback, or removes the
  /// currently set callback.  This is called when a joystick is connected to or
  /// disconnected from the system.
  ///
  /// For joystick connection and disconnection events to be delivered on all
  /// platforms, you need to call one of the [event processing](@ref events)
  /// functions.  Joystick disconnection may also be detected and the callback
  /// called by joystick functions.  The function will then return whatever it
  /// returns if the joystick is not present.
  ///
  /// @param[in] callback The new callback, or `NULL` to remove the currently set
  /// callback.
  /// @return The previously set callback, or `NULL` if no callback was set or the
  /// library had not been [initialized](@ref intro_init).
  ///
  /// @callback_signature
  /// @code
  /// void function_name(int jid, int event)
  /// @endcode
  /// For more information about the callback parameters, see the
  /// [function pointer type](@ref GLFWjoystickfun).
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref joystick_event
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup input
  GLFWjoystickfun glfwSetJoystickCallback(
    GLFWjoystickfun callback,
  ) {
    return _glfwSetJoystickCallback(
      callback,
    );
  }

  late final _glfwSetJoystickCallbackPtr =
      _lookup<ffi.NativeFunction<GLFWjoystickfun Function(GLFWjoystickfun)>>(
          'glfwSetJoystickCallback');
  late final _glfwSetJoystickCallback = _glfwSetJoystickCallbackPtr
      .asFunction<GLFWjoystickfun Function(GLFWjoystickfun)>();

  /// ! @brief Adds the specified SDL_GameControllerDB gamepad mappings.
  ///
  /// This function parses the specified ASCII encoded string and updates the
  /// internal list with any gamepad mappings it finds.  This string may
  /// contain either a single gamepad mapping or many mappings separated by
  /// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`
  /// source file including empty lines and comments.
  ///
  /// See @ref gamepad_mapping for a description of the format.
  ///
  /// If there is already a gamepad mapping for a given GUID in the internal list,
  /// it will be replaced by the one passed to this function.  If the library is
  /// terminated and re-initialized the internal list will revert to the built-in
  /// default.
  ///
  /// @param[in] string The string containing the gamepad mappings.
  /// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_VALUE.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref gamepad
  /// @sa @ref glfwJoystickIsGamepad
  /// @sa @ref glfwGetGamepadName
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  int glfwUpdateGamepadMappings(
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _glfwUpdateGamepadMappings(
      string,
    );
  }

  late final _glfwUpdateGamepadMappingsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'glfwUpdateGamepadMappings');
  late final _glfwUpdateGamepadMappings = _glfwUpdateGamepadMappingsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Returns the human-readable gamepad name for the specified joystick.
  ///
  /// This function returns the human-readable name of the gamepad from the
  /// gamepad mapping assigned to the specified joystick.
  ///
  /// If the specified joystick is not present or does not have a gamepad mapping
  /// this function will return `NULL` but will not generate an error.  Call
  /// @ref glfwJoystickPresent to check whether it is present regardless of
  /// whether it has a mapping.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @return The UTF-8 encoded name of the gamepad, or `NULL` if the
  /// joystick is not present, does not have a mapping or an
  /// [error](@ref error_handling) occurred.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the specified joystick is
  /// disconnected, the gamepad mappings are updated or the library is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref gamepad
  /// @sa @ref glfwJoystickIsGamepad
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Int8> glfwGetGamepadName(
    int jid,
  ) {
    return _glfwGetGamepadName(
      jid,
    );
  }

  late final _glfwGetGamepadNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'glfwGetGamepadName');
  late final _glfwGetGamepadName =
      _glfwGetGamepadNamePtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  /// ! @brief Retrieves the state of the specified joystick remapped as a gamepad.
  ///
  /// This function retrieves the state of the specified joystick remapped to
  /// an Xbox-like gamepad.
  ///
  /// If the specified joystick is not present or does not have a gamepad mapping
  /// this function will return `GLFW_FALSE` but will not generate an error.  Call
  /// @ref glfwJoystickPresent to check whether it is present regardless of
  /// whether it has a mapping.
  ///
  /// The Guide button may not be available for input as it is often hooked by the
  /// system or the Steam client.
  ///
  /// Not all devices have all the buttons or axes provided by @ref
  /// GLFWgamepadstate.  Unavailable buttons and axes will always report
  /// `GLFW_RELEASE` and 0.0 respectively.
  ///
  /// @param[in] jid The [joystick](@ref joysticks) to query.
  /// @param[out] state The gamepad input state of the joystick.
  /// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is
  /// connected, it has no gamepad mapping or an [error](@ref error_handling)
  /// occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_ENUM.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref gamepad
  /// @sa @ref glfwUpdateGamepadMappings
  /// @sa @ref glfwJoystickIsGamepad
  ///
  /// @since Added in version 3.3.
  ///
  /// @ingroup input
  int glfwGetGamepadState(
    int jid,
    ffi.Pointer<GLFWgamepadstate> state,
  ) {
    return _glfwGetGamepadState(
      jid,
      state,
    );
  }

  late final _glfwGetGamepadStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32,
              ffi.Pointer<GLFWgamepadstate>)>>('glfwGetGamepadState');
  late final _glfwGetGamepadState = _glfwGetGamepadStatePtr
      .asFunction<int Function(int, ffi.Pointer<GLFWgamepadstate>)>();

  /// ! @brief Sets the clipboard to the specified string.
  ///
  /// This function sets the system clipboard to the specified, UTF-8 encoded
  /// string.
  ///
  /// @param[in] window Deprecated.  Any valid window or `NULL`.
  /// @param[in] string A UTF-8 encoded string.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The specified string is copied before this function
  /// returns.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref clipboard
  /// @sa @ref glfwGetClipboardString
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup input
  void glfwSetClipboardString(
    ffi.Pointer<GLFWwindow> window,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _glfwSetClipboardString(
      window,
      string,
    );
  }

  late final _glfwSetClipboardStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GLFWwindow>,
              ffi.Pointer<ffi.Int8>)>>('glfwSetClipboardString');
  late final _glfwSetClipboardString = _glfwSetClipboardStringPtr.asFunction<
      void Function(ffi.Pointer<GLFWwindow>, ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Returns the contents of the clipboard as a string.
  ///
  /// This function returns the contents of the system clipboard, if it contains
  /// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
  /// if its contents cannot be converted, `NULL` is returned and a @ref
  /// GLFW_FORMAT_UNAVAILABLE error is generated.
  ///
  /// @param[in] window Deprecated.  Any valid window or `NULL`.
  /// @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`
  /// if an [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @pointer_lifetime The returned string is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is valid until the next call to @ref
  /// glfwGetClipboardString or @ref glfwSetClipboardString, or until the library
  /// is terminated.
  ///
  /// @thread_safety This function must only be called from the main thread.
  ///
  /// @sa @ref clipboard
  /// @sa @ref glfwSetClipboardString
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup input
  ffi.Pointer<ffi.Int8> glfwGetClipboardString(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwGetClipboardString(
      window,
    );
  }

  late final _glfwGetClipboardStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<GLFWwindow>)>>('glfwGetClipboardString');
  late final _glfwGetClipboardString = _glfwGetClipboardStringPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Returns the GLFW time.
  ///
  /// This function returns the current GLFW time, in seconds.  Unless the time
  /// has been set using @ref glfwSetTime it measures time elapsed since GLFW was
  /// initialized.
  ///
  /// This function and @ref glfwSetTime are helper functions on top of @ref
  /// glfwGetTimerFrequency and @ref glfwGetTimerValue.
  ///
  /// The resolution of the timer is system dependent, but is usually on the order
  /// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
  /// time source on each supported platform.
  ///
  /// @return The current time, in seconds, or zero if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.  Reading and
  /// writing of the internal base time is not atomic, so it needs to be
  /// externally synchronized with calls to @ref glfwSetTime.
  ///
  /// @sa @ref time
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup input
  double glfwGetTime() {
    return _glfwGetTime();
  }

  late final _glfwGetTimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('glfwGetTime');
  late final _glfwGetTime = _glfwGetTimePtr.asFunction<double Function()>();

  /// ! @brief Sets the GLFW time.
  ///
  /// This function sets the current GLFW time, in seconds.  The value must be
  /// a positive finite number less than or equal to 18446744073.0, which is
  /// approximately 584.5 years.
  ///
  /// This function and @ref glfwGetTime are helper functions on top of @ref
  /// glfwGetTimerFrequency and @ref glfwGetTimerValue.
  ///
  /// @param[in] time The new value, in seconds.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_INVALID_VALUE.
  ///
  /// @remark The upper limit of GLFW time is calculated as
  /// floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations
  /// storing nanoseconds in 64 bits.  The limit may be increased in the future.
  ///
  /// @thread_safety This function may be called from any thread.  Reading and
  /// writing of the internal base time is not atomic, so it needs to be
  /// externally synchronized with calls to @ref glfwGetTime.
  ///
  /// @sa @ref time
  ///
  /// @since Added in version 2.2.
  ///
  /// @ingroup input
  void glfwSetTime(
    double time,
  ) {
    return _glfwSetTime(
      time,
    );
  }

  late final _glfwSetTimePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Double)>>('glfwSetTime');
  late final _glfwSetTime = _glfwSetTimePtr.asFunction<void Function(double)>();

  /// ! @brief Returns the current value of the raw timer.
  ///
  /// This function returns the current value of the raw timer, measured in
  /// 1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref
  /// glfwGetTimerFrequency.
  ///
  /// @return The value of the timer, or zero if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref time
  /// @sa @ref glfwGetTimerFrequency
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup input
  int glfwGetTimerValue() {
    return _glfwGetTimerValue();
  }

  late final _glfwGetTimerValuePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('glfwGetTimerValue');
  late final _glfwGetTimerValue =
      _glfwGetTimerValuePtr.asFunction<int Function()>();

  /// ! @brief Returns the frequency, in Hz, of the raw timer.
  ///
  /// This function returns the frequency, in Hz, of the raw timer.
  ///
  /// @return The frequency of the timer, in Hz, or zero if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref time
  /// @sa @ref glfwGetTimerValue
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup input
  int glfwGetTimerFrequency() {
    return _glfwGetTimerFrequency();
  }

  late final _glfwGetTimerFrequencyPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>(
          'glfwGetTimerFrequency');
  late final _glfwGetTimerFrequency =
      _glfwGetTimerFrequencyPtr.asFunction<int Function()>();

  /// ! @brief Makes the context of the specified window current for the calling
  /// thread.
  ///
  /// This function makes the OpenGL or OpenGL ES context of the specified window
  /// current on the calling thread.  A context must only be made current on
  /// a single thread at a time and each thread can have only a single current
  /// context at a time.
  ///
  /// When moving a context between threads, you must make it non-current on the
  /// old thread before making it current on the new one.
  ///
  /// By default, making a context non-current implicitly forces a pipeline flush.
  /// On machines that support `GL_KHR_context_flush_control`, you can control
  /// whether a context performs this flush by setting the
  /// [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)
  /// hint.
  ///
  /// The specified window must have an OpenGL or OpenGL ES context.  Specifying
  /// a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT
  /// error.
  ///
  /// @param[in] window The window whose context to make current, or `NULL` to
  /// detach the current context.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref context_current
  /// @sa @ref glfwGetCurrentContext
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup context
  void glfwMakeContextCurrent(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwMakeContextCurrent(
      window,
    );
  }

  late final _glfwMakeContextCurrentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwMakeContextCurrent');
  late final _glfwMakeContextCurrent = _glfwMakeContextCurrentPtr
      .asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Returns the window whose context is current on the calling thread.
  ///
  /// This function returns the window whose OpenGL or OpenGL ES context is
  /// current on the calling thread.
  ///
  /// @return The window whose context is current, or `NULL` if no window's
  /// context is current.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref context_current
  /// @sa @ref glfwMakeContextCurrent
  ///
  /// @since Added in version 3.0.
  ///
  /// @ingroup context
  ffi.Pointer<GLFWwindow> glfwGetCurrentContext() {
    return _glfwGetCurrentContext();
  }

  late final _glfwGetCurrentContextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GLFWwindow> Function()>>(
          'glfwGetCurrentContext');
  late final _glfwGetCurrentContext = _glfwGetCurrentContextPtr
      .asFunction<ffi.Pointer<GLFWwindow> Function()>();

  /// ! @brief Swaps the front and back buffers of the specified window.
  ///
  /// This function swaps the front and back buffers of the specified window when
  /// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
  /// zero, the GPU driver waits the specified number of screen updates before
  /// swapping the buffers.
  ///
  /// The specified window must have an OpenGL or OpenGL ES context.  Specifying
  /// a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT
  /// error.
  ///
  /// This function does not apply to Vulkan.  If you are rendering with Vulkan,
  /// see `vkQueuePresentKHR` instead.
  ///
  /// @param[in] window The window whose buffers to swap.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark __EGL:__ The context of the specified window must be current on the
  /// calling thread.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref buffer_swap
  /// @sa @ref glfwSwapInterval
  ///
  /// @since Added in version 1.0.
  /// @glfw3 Added window handle parameter.
  ///
  /// @ingroup window
  void glfwSwapBuffers(
    ffi.Pointer<GLFWwindow> window,
  ) {
    return _glfwSwapBuffers(
      window,
    );
  }

  late final _glfwSwapBuffersPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>(
          'glfwSwapBuffers');
  late final _glfwSwapBuffers =
      _glfwSwapBuffersPtr.asFunction<void Function(ffi.Pointer<GLFWwindow>)>();

  /// ! @brief Sets the swap interval for the current context.
  ///
  /// This function sets the swap interval for the current OpenGL or OpenGL ES
  /// context, i.e. the number of screen updates to wait from the time @ref
  /// glfwSwapBuffers was called before swapping the buffers and returning.  This
  /// is sometimes called _vertical synchronization_, _vertical retrace
  /// synchronization_ or just _vsync_.
  ///
  /// A context that supports either of the `WGL_EXT_swap_control_tear` and
  /// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap
  /// intervals, which allows the driver to swap immediately even if a frame
  /// arrives a little bit late.  You can check for these extensions with @ref
  /// glfwExtensionSupported.
  ///
  /// A context must be current on the calling thread.  Calling this function
  /// without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
  ///
  /// This function does not apply to Vulkan.  If you are rendering with Vulkan,
  /// see the present mode of your swapchain instead.
  ///
  /// @param[in] interval The minimum number of screen updates to wait for
  /// until the buffers are swapped by @ref glfwSwapBuffers.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark This function is not called during context creation, leaving the
  /// swap interval set to whatever is the default on that platform.  This is done
  /// because some swap interval extensions used by GLFW do not allow the swap
  /// interval to be reset to zero once it has been set to a non-zero value.
  ///
  /// @remark Some GPU drivers do not honor the requested swap interval, either
  /// because of a user setting that overrides the application's request or due to
  /// bugs in the driver.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref buffer_swap
  /// @sa @ref glfwSwapBuffers
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup context
  void glfwSwapInterval(
    int interval,
  ) {
    return _glfwSwapInterval(
      interval,
    );
  }

  late final _glfwSwapIntervalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'glfwSwapInterval');
  late final _glfwSwapInterval =
      _glfwSwapIntervalPtr.asFunction<void Function(int)>();

  /// ! @brief Returns whether the specified extension is available.
  ///
  /// This function returns whether the specified
  /// [API extension](@ref context_glext) is supported by the current OpenGL or
  /// OpenGL ES context.  It searches both for client API extension and context
  /// creation API extensions.
  ///
  /// A context must be current on the calling thread.  Calling this function
  /// without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
  ///
  /// As this functions retrieves and searches one or more extension strings each
  /// call, it is recommended that you cache its results if it is going to be used
  /// frequently.  The extension strings will not change during the lifetime of
  /// a context, so there is no danger in doing this.
  ///
  /// This function does not apply to Vulkan.  If you are using Vulkan, see @ref
  /// glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`
  /// and `vkEnumerateDeviceExtensionProperties` instead.
  ///
  /// @param[in] extension The ASCII encoded name of the extension.
  /// @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
  /// otherwise.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref
  /// GLFW_PLATFORM_ERROR.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref context_glext
  /// @sa @ref glfwGetProcAddress
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup context
  int glfwExtensionSupported(
    ffi.Pointer<ffi.Int8> extension1,
  ) {
    return _glfwExtensionSupported(
      extension1,
    );
  }

  late final _glfwExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'glfwExtensionSupported');
  late final _glfwExtensionSupported = _glfwExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Returns the address of the specified function for the current
  /// context.
  ///
  /// This function returns the address of the specified OpenGL or OpenGL ES
  /// [core or extension function](@ref context_glext), if it is supported
  /// by the current context.
  ///
  /// A context must be current on the calling thread.  Calling this function
  /// without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.
  ///
  /// This function does not apply to Vulkan.  If you are rendering with Vulkan,
  /// see @ref glfwGetInstanceProcAddress, `vkGetInstanceProcAddr` and
  /// `vkGetDeviceProcAddr` instead.
  ///
  /// @param[in] procname The ASCII encoded name of the function.
  /// @return The address of the function, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
  /// GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.
  ///
  /// @remark The address of a given function is not guaranteed to be the same
  /// between contexts.
  ///
  /// @remark This function may return a non-`NULL` address despite the
  /// associated version or extension not being available.  Always check the
  /// context version or extension string first.
  ///
  /// @pointer_lifetime The returned function pointer is valid until the context
  /// is destroyed or the library is terminated.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref context_glext
  /// @sa @ref glfwExtensionSupported
  ///
  /// @since Added in version 1.0.
  ///
  /// @ingroup context
  GLFWglproc glfwGetProcAddress(
    ffi.Pointer<ffi.Int8> procname,
  ) {
    return _glfwGetProcAddress(
      procname,
    );
  }

  late final _glfwGetProcAddressPtr =
      _lookup<ffi.NativeFunction<GLFWglproc Function(ffi.Pointer<ffi.Int8>)>>(
          'glfwGetProcAddress');
  late final _glfwGetProcAddress = _glfwGetProcAddressPtr
      .asFunction<GLFWglproc Function(ffi.Pointer<ffi.Int8>)>();

  /// ! @brief Returns whether the Vulkan loader and an ICD have been found.
  ///
  /// This function returns whether the Vulkan loader and any minimally functional
  /// ICD have been found.
  ///
  /// The availability of a Vulkan loader and even an ICD does not by itself guarantee that
  /// surface creation or even instance creation is possible.  Call @ref
  /// glfwGetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan
  /// surface creation are available and @ref glfwGetPhysicalDevicePresentationSupport to
  /// check whether a queue family of a physical device supports image presentation.
  ///
  /// @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`
  /// otherwise.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref vulkan_support
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup vulkan
  int glfwVulkanSupported() {
    return _glfwVulkanSupported();
  }

  late final _glfwVulkanSupportedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('glfwVulkanSupported');
  late final _glfwVulkanSupported =
      _glfwVulkanSupportedPtr.asFunction<int Function()>();

  /// ! @brief Returns the Vulkan instance extensions required by GLFW.
  ///
  /// This function returns an array of names of Vulkan instance extensions required
  /// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
  /// list will always contain `VK_KHR_surface`, so if you don't require any
  /// additional extensions you can pass this list directly to the
  /// `VkInstanceCreateInfo` struct.
  ///
  /// If Vulkan is not available on the machine, this function returns `NULL` and
  /// generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported
  /// to check whether Vulkan is at least minimally available.
  ///
  /// If Vulkan is available but no set of extensions allowing window surface
  /// creation was found, this function returns `NULL`.  You may still use Vulkan
  /// for off-screen rendering and compute work.
  ///
  /// @param[out] count Where to store the number of extensions in the returned
  /// array.  This is set to zero if an error occurred.
  /// @return An array of ASCII encoded extension names, or `NULL` if an
  /// [error](@ref error_handling) occurred.
  ///
  /// @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  /// GLFW_API_UNAVAILABLE.
  ///
  /// @remark Additional extensions may be required by future versions of GLFW.
  /// You should check if any extensions you wish to enable are already in the
  /// returned array, as it is an error to specify an extension more than once in
  /// the `VkInstanceCreateInfo` struct.
  ///
  /// @remark @macos GLFW currently supports both the `VK_MVK_macos_surface` and
  /// the newer `VK_EXT_metal_surface` extensions.
  ///
  /// @pointer_lifetime The returned array is allocated and freed by GLFW.  You
  /// should not free it yourself.  It is guaranteed to be valid only until the
  /// library is terminated.
  ///
  /// @thread_safety This function may be called from any thread.
  ///
  /// @sa @ref vulkan_ext
  /// @sa @ref glfwCreateWindowSurface
  ///
  /// @since Added in version 3.2.
  ///
  /// @ingroup vulkan
  ffi.Pointer<ffi.Pointer<ffi.Int8>> glfwGetRequiredInstanceExtensions(
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _glfwGetRequiredInstanceExtensions(
      count,
    );
  }

  late final _glfwGetRequiredInstanceExtensionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Int8>> Function(
              ffi.Pointer<ffi.Uint32>)>>('glfwGetRequiredInstanceExtensions');
  late final _glfwGetRequiredInstanceExtensions =
      _glfwGetRequiredInstanceExtensionsPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Int8>> Function(
              ffi.Pointer<ffi.Uint32>)>();
}

typedef va_list = ffi.Pointer<ffi.Int8>;
typedef uintptr_t = ffi.Uint64;
typedef wchar_t = ffi.Uint16;

class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> _locale_pctype;

  @ffi.Int32()
  external int _locale_mb_cur_max;

  @ffi.Uint32()
  external int _locale_lc_codepage;
}

class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

class __crt_locale_data extends ffi.Opaque {}

class __crt_multibyte_data extends ffi.Opaque {}

class _Mbstatet extends ffi.Struct {
  @ffi.Uint64()
  external int _Wchar;

  @ffi.Uint16()
  external int _Byte;

  @ffi.Uint16()
  external int _State;
}

typedef errno_t = ffi.Int32;
typedef GLenum = ffi.Uint32;
typedef GLfloat = ffi.Float;
typedef GLclampf = ffi.Float;
typedef GLboolean = ffi.Uint8;
typedef GLsizei = ffi.Int32;
typedef GLuint = ffi.Uint32;
typedef GLint = ffi.Int32;
typedef GLubyte = ffi.Uint8;
typedef GLvoid = ffi.Void;
typedef GLbitfield = ffi.Uint32;
typedef GLclampd = ffi.Double;
typedef GLdouble = ffi.Double;
typedef GLbyte = ffi.Int8;
typedef GLshort = ffi.Int16;
typedef GLushort = ffi.Uint16;

class GLFWmonitor extends ffi.Opaque {}

class GLFWwindow extends ffi.Opaque {}

class GLFWcursor extends ffi.Opaque {}

/// ! @brief Video mode type.
///
/// This describes a single video mode.
///
/// @sa @ref monitor_modes
/// @sa @ref glfwGetVideoMode
/// @sa @ref glfwGetVideoModes
///
/// @since Added in version 1.0.
/// @glfw3 Added refresh rate member.
///
/// @ingroup monitor
class GLFWvidmode extends ffi.Struct {
  /// ! The width, in screen coordinates, of the video mode.
  @ffi.Int32()
  external int width;

  /// ! The height, in screen coordinates, of the video mode.
  @ffi.Int32()
  external int height;

  /// ! The bit depth of the red channel of the video mode.
  @ffi.Int32()
  external int redBits;

  /// ! The bit depth of the green channel of the video mode.
  @ffi.Int32()
  external int greenBits;

  /// ! The bit depth of the blue channel of the video mode.
  @ffi.Int32()
  external int blueBits;

  /// ! The refresh rate, in Hz, of the video mode.
  @ffi.Int32()
  external int refreshRate;
}

/// ! @brief Gamma ramp.
///
/// This describes the gamma ramp for a monitor.
///
/// @sa @ref monitor_gamma
/// @sa @ref glfwGetGammaRamp
/// @sa @ref glfwSetGammaRamp
///
/// @since Added in version 3.0.
///
/// @ingroup monitor
class GLFWgammaramp extends ffi.Struct {
  /// ! An array of value describing the response of the red channel.
  external ffi.Pointer<ffi.Uint16> red;

  /// ! An array of value describing the response of the green channel.
  external ffi.Pointer<ffi.Uint16> green;

  /// ! An array of value describing the response of the blue channel.
  external ffi.Pointer<ffi.Uint16> blue;

  /// ! The number of elements in each array.
  @ffi.Uint32()
  external int size;
}

/// ! @brief Image data.
///
/// This describes a single 2D image.  See the documentation for each related
/// function what the expected pixel format is.
///
/// @sa @ref cursor_custom
/// @sa @ref window_icon
///
/// @since Added in version 2.1.
/// @glfw3 Removed format and bytes-per-pixel members.
///
/// @ingroup window
class GLFWimage extends ffi.Struct {
  /// ! The width, in pixels, of this image.
  @ffi.Int32()
  external int width;

  /// ! The height, in pixels, of this image.
  @ffi.Int32()
  external int height;

  /// ! The pixel data of this image, arranged left-to-right, top-to-bottom.
  external ffi.Pointer<ffi.Uint8> pixels;
}

/// ! @brief Gamepad input state
///
/// This describes the input state of a gamepad.
///
/// @sa @ref gamepad
/// @sa @ref glfwGetGamepadState
///
/// @since Added in version 3.3.
///
/// @ingroup input
class GLFWgamepadstate extends ffi.Struct {
  @ffi.Array.multi([15])
  external ffi.Array<ffi.Uint8> buttons;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Float> axes;
}

/// ! @brief The function pointer type for error callbacks.
///
/// This is the function pointer type for error callbacks.  An error callback
/// function has the following signature:
/// @code
/// void callback_name(int error_code, const char* description)
/// @endcode
///
/// @param[in] error_code An [error code](@ref errors).  Future releases may add
/// more error codes.
/// @param[in] description A UTF-8 encoded string describing the error.
///
/// @pointer_lifetime The error description string is valid until the callback
/// function returns.
///
/// @sa @ref error_handling
/// @sa @ref glfwSetErrorCallback
///
/// @since Added in version 3.0.
///
/// @ingroup init
typedef GLFWerrorfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>;

/// ! @brief The function pointer type for monitor configuration callbacks.
///
/// This is the function pointer type for monitor configuration callbacks.
/// A monitor callback function has the following signature:
/// @code
/// void function_name(GLFWmonitor* monitor, int event)
/// @endcode
///
/// @param[in] monitor The monitor that was connected or disconnected.
/// @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
/// releases may add more events.
///
/// @sa @ref monitor_event
/// @sa @ref glfwSetMonitorCallback
///
/// @since Added in version 3.0.
///
/// @ingroup monitor
typedef GLFWmonitorfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWmonitor>, ffi.Int32)>>;

/// ! @brief The function pointer type for window position callbacks.
///
/// This is the function pointer type for window position callbacks.  A window
/// position callback function has the following signature:
/// @code
/// void callback_name(GLFWwindow* window, int xpos, int ypos)
/// @endcode
///
/// @param[in] window The window that was moved.
/// @param[in] xpos The new x-coordinate, in screen coordinates, of the
/// upper-left corner of the content area of the window.
/// @param[in] ypos The new y-coordinate, in screen coordinates, of the
/// upper-left corner of the content area of the window.
///
/// @sa @ref window_pos
/// @sa @ref glfwSetWindowPosCallback
///
/// @since Added in version 3.0.
///
/// @ingroup window
typedef GLFWwindowposfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32)>>;

/// ! @brief The function pointer type for window size callbacks.
///
/// This is the function pointer type for window size callbacks.  A window size
/// callback function has the following signature:
/// @code
/// void callback_name(GLFWwindow* window, int width, int height)
/// @endcode
///
/// @param[in] window The window that was resized.
/// @param[in] width The new width, in screen coordinates, of the window.
/// @param[in] height The new height, in screen coordinates, of the window.
///
/// @sa @ref window_size
/// @sa @ref glfwSetWindowSizeCallback
///
/// @since Added in version 1.0.
/// @glfw3 Added window handle parameter.
///
/// @ingroup window
typedef GLFWwindowsizefun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32)>>;

/// ! @brief The function pointer type for window close callbacks.
///
/// This is the function pointer type for window close callbacks.  A window
/// close callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window)
/// @endcode
///
/// @param[in] window The window that the user attempted to close.
///
/// @sa @ref window_close
/// @sa @ref glfwSetWindowCloseCallback
///
/// @since Added in version 2.5.
/// @glfw3 Added window handle parameter.
///
/// @ingroup window
typedef GLFWwindowclosefun = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>;

/// ! @brief The function pointer type for window content refresh callbacks.
///
/// This is the function pointer type for window content refresh callbacks.
/// A window content refresh callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window);
/// @endcode
///
/// @param[in] window The window whose content needs to be refreshed.
///
/// @sa @ref window_refresh
/// @sa @ref glfwSetWindowRefreshCallback
///
/// @since Added in version 2.5.
/// @glfw3 Added window handle parameter.
///
/// @ingroup window
typedef GLFWwindowrefreshfun = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>)>>;

/// ! @brief The function pointer type for window focus callbacks.
///
/// This is the function pointer type for window focus callbacks.  A window
/// focus callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int focused)
/// @endcode
///
/// @param[in] window The window that gained or lost input focus.
/// @param[in] focused `GLFW_TRUE` if the window was given input focus, or
/// `GLFW_FALSE` if it lost it.
///
/// @sa @ref window_focus
/// @sa @ref glfwSetWindowFocusCallback
///
/// @since Added in version 3.0.
///
/// @ingroup window
typedef GLFWwindowfocusfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32)>>;

/// ! @brief The function pointer type for window iconify callbacks.
///
/// This is the function pointer type for window iconify callbacks.  A window
/// iconify callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int iconified)
/// @endcode
///
/// @param[in] window The window that was iconified or restored.
/// @param[in] iconified `GLFW_TRUE` if the window was iconified, or
/// `GLFW_FALSE` if it was restored.
///
/// @sa @ref window_iconify
/// @sa @ref glfwSetWindowIconifyCallback
///
/// @since Added in version 3.0.
///
/// @ingroup window
typedef GLFWwindowiconifyfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32)>>;

/// ! @brief The function pointer type for window maximize callbacks.
///
/// This is the function pointer type for window maximize callbacks.  A window
/// maximize callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int maximized)
/// @endcode
///
/// @param[in] window The window that was maximized or restored.
/// @param[in] maximized `GLFW_TRUE` if the window was maximized, or
/// `GLFW_FALSE` if it was restored.
///
/// @sa @ref window_maximize
/// @sa glfwSetWindowMaximizeCallback
///
/// @since Added in version 3.3.
///
/// @ingroup window
typedef GLFWwindowmaximizefun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32)>>;

/// ! @brief The function pointer type for framebuffer size callbacks.
///
/// This is the function pointer type for framebuffer size callbacks.
/// A framebuffer size callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int width, int height)
/// @endcode
///
/// @param[in] window The window whose framebuffer was resized.
/// @param[in] width The new width, in pixels, of the framebuffer.
/// @param[in] height The new height, in pixels, of the framebuffer.
///
/// @sa @ref window_fbsize
/// @sa @ref glfwSetFramebufferSizeCallback
///
/// @since Added in version 3.0.
///
/// @ingroup window
typedef GLFWframebuffersizefun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32)>>;

/// ! @brief The function pointer type for window content scale callbacks.
///
/// This is the function pointer type for window content scale callbacks.
/// A window content scale callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, float xscale, float yscale)
/// @endcode
///
/// @param[in] window The window whose content scale changed.
/// @param[in] xscale The new x-axis content scale of the window.
/// @param[in] yscale The new y-axis content scale of the window.
///
/// @sa @ref window_scale
/// @sa @ref glfwSetWindowContentScaleCallback
///
/// @since Added in version 3.3.
///
/// @ingroup window
typedef GLFWwindowcontentscalefun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Float, ffi.Float)>>;

/// ! @brief The function pointer type for keyboard key callbacks.
///
/// This is the function pointer type for keyboard key callbacks.  A keyboard
/// key callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] key The [keyboard key](@ref keys) that was pressed or released.
/// @param[in] scancode The system-specific scancode of the key.
/// @param[in] action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future
/// releases may add more actions.
/// @param[in] mods Bit field describing which [modifier keys](@ref mods) were
/// held down.
///
/// @sa @ref input_key
/// @sa @ref glfwSetKeyCallback
///
/// @since Added in version 1.0.
/// @glfw3 Added window handle, scancode and modifier mask parameters.
///
/// @ingroup input
typedef GLFWkeyfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32,
            ffi.Int32, ffi.Int32)>>;

/// ! @brief The function pointer type for Unicode character callbacks.
///
/// This is the function pointer type for Unicode character callbacks.
/// A Unicode character callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, unsigned int codepoint)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] codepoint The Unicode code point of the character.
///
/// @sa @ref input_char
/// @sa @ref glfwSetCharCallback
///
/// @since Added in version 2.4.
/// @glfw3 Added window handle parameter.
///
/// @ingroup input
typedef GLFWcharfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Uint32)>>;

/// ! @brief The function pointer type for Unicode character with modifiers
/// callbacks.
///
/// This is the function pointer type for Unicode character with modifiers
/// callbacks.  It is called for each input character, regardless of what
/// modifier keys are held down.  A Unicode character with modifiers callback
/// function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, unsigned int codepoint, int mods)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] codepoint The Unicode code point of the character.
/// @param[in] mods Bit field describing which [modifier keys](@ref mods) were
/// held down.
///
/// @sa @ref input_char
/// @sa @ref glfwSetCharModsCallback
///
/// @deprecated Scheduled for removal in version 4.0.
///
/// @since Added in version 3.1.
///
/// @ingroup input
typedef GLFWcharmodsfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Uint32, ffi.Int32)>>;

/// ! @brief The function pointer type for mouse button callbacks.
///
/// This is the function pointer type for mouse button callback functions.
/// A mouse button callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int button, int action, int mods)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] button The [mouse button](@ref buttons) that was pressed or
/// released.
/// @param[in] action One of `GLFW_PRESS` or `GLFW_RELEASE`.  Future releases
/// may add more actions.
/// @param[in] mods Bit field describing which [modifier keys](@ref mods) were
/// held down.
///
/// @sa @ref input_mouse_button
/// @sa @ref glfwSetMouseButtonCallback
///
/// @since Added in version 1.0.
/// @glfw3 Added window handle and modifier mask parameters.
///
/// @ingroup input
typedef GLFWmousebuttonfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<GLFWwindow>, ffi.Int32, ffi.Int32, ffi.Int32)>>;

/// ! @brief The function pointer type for cursor position callbacks.
///
/// This is the function pointer type for cursor position callbacks.  A cursor
/// position callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, double xpos, double ypos);
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] xpos The new cursor x-coordinate, relative to the left edge of
/// the content area.
/// @param[in] ypos The new cursor y-coordinate, relative to the top edge of the
/// content area.
///
/// @sa @ref cursor_pos
/// @sa @ref glfwSetCursorPosCallback
///
/// @since Added in version 3.0.  Replaces `GLFWmouseposfun`.
///
/// @ingroup input
typedef GLFWcursorposfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Double, ffi.Double)>>;

/// ! @brief The function pointer type for cursor enter/leave callbacks.
///
/// This is the function pointer type for cursor enter/leave callbacks.
/// A cursor enter/leave callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int entered)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] entered `GLFW_TRUE` if the cursor entered the window's content
/// area, or `GLFW_FALSE` if it left it.
///
/// @sa @ref cursor_enter
/// @sa @ref glfwSetCursorEnterCallback
///
/// @since Added in version 3.0.
///
/// @ingroup input
typedef GLFWcursorenterfun = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32)>>;

/// ! @brief The function pointer type for scroll callbacks.
///
/// This is the function pointer type for scroll callbacks.  A scroll callback
/// function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, double xoffset, double yoffset)
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] xoffset The scroll offset along the x-axis.
/// @param[in] yoffset The scroll offset along the y-axis.
///
/// @sa @ref scrolling
/// @sa @ref glfwSetScrollCallback
///
/// @since Added in version 3.0.  Replaces `GLFWmousewheelfun`.
///
/// @ingroup input
typedef GLFWscrollfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Double, ffi.Double)>>;

/// ! @brief The function pointer type for path drop callbacks.
///
/// This is the function pointer type for path drop callbacks.  A path drop
/// callback function has the following signature:
/// @code
/// void function_name(GLFWwindow* window, int path_count, const char* paths[])
/// @endcode
///
/// @param[in] window The window that received the event.
/// @param[in] path_count The number of dropped paths.
/// @param[in] paths The UTF-8 encoded file and/or directory path names.
///
/// @pointer_lifetime The path array and its strings are valid until the
/// callback function returns.
///
/// @sa @ref path_drop
/// @sa @ref glfwSetDropCallback
///
/// @since Added in version 3.1.
///
/// @ingroup input
typedef GLFWdropfun = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<GLFWwindow>, ffi.Int32,
            ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>;

/// ! @brief The function pointer type for joystick configuration callbacks.
///
/// This is the function pointer type for joystick configuration callbacks.
/// A joystick configuration callback function has the following signature:
/// @code
/// void function_name(int jid, int event)
/// @endcode
///
/// @param[in] jid The joystick that was connected or disconnected.
/// @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
/// releases may add more events.
///
/// @sa @ref joystick_event
/// @sa @ref glfwSetJoystickCallback
///
/// @since Added in version 3.2.
///
/// @ingroup input
typedef GLFWjoystickfun
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>;

/// ! @brief Client API function pointer type.
///
/// Generic function pointer used for returning client API function pointers
/// without forcing a cast from a regular pointer.
///
/// @sa @ref context_glext
/// @sa @ref glfwGetProcAddress
///
/// @since Added in version 3.0.
///
/// @ingroup context
typedef GLFWglproc = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int WINAPI_PARTITION_SERVER = 0;

const int WINAPI_PARTITION_PKG_WINTRUST = 0;

const int WINAPI_PARTITION_PKG_WEBSERVICES = 0;

const int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = 0;

const int WINAPI_PARTITION_PKG_VHD = 0;

const int WINAPI_PARTITION_PKG_PERFCOUNTER = 0;

const int WINAPI_PARTITION_PKG_SECURESTARTUP = 0;

const int WINAPI_PARTITION_PKG_REMOTEFS = 0;

const int WINAPI_PARTITION_PKG_BOOTABLESKU = 0;

const int WINAPI_PARTITION_PKG_CMDTOOLS = 0;

const int WINAPI_PARTITION_PKG_DISM = 0;

const int WINAPI_PARTITION_PKG_CORESETUP = 0;

const int WINAPI_PARTITION_PKG_APPRUNTIME = 0;

const int WINAPI_PARTITION_PKG_ESENT = 0;

const int WINAPI_PARTITION_PKG_WINMGMT = 0;

const int WINAPI_PARTITION_PKG_WNV = 0;

const int WINAPI_PARTITION_PKG_CLUSTER = 0;

const int WINAPI_PARTITION_PKG_VSS = 0;

const int WINAPI_PARTITION_PKG_TRAFFIC = 0;

const int WINAPI_PARTITION_PKG_ISCSI = 0;

const int WINAPI_PARTITION_PKG_STORAGE = 0;

const int WINAPI_PARTITION_PKG_MPSSVC = 0;

const int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = 0;

const int WINAPI_PARTITION_PKG_WER = 0;

const int WINAPI_FAMILY_PC_APP = 2;

const int WINAPI_FAMILY_PHONE_APP = 3;

const int WINAPI_FAMILY_SYSTEM = 4;

const int WINAPI_FAMILY_SERVER = 5;

const int WINAPI_FAMILY_GAMES = 6;

const int WINAPI_FAMILY_DESKTOP_APP = 100;

const int WINAPI_FAMILY_APP = 2;

const int WINAPI_FAMILY = 100;

const int WINAPI_PARTITION_DESKTOP = 1;

const int WINAPI_PARTITION_APP = 1;

const int WINAPI_PARTITION_PC_APP = 1;

const int WINAPI_PARTITION_PHONE_APP = 0;

const int WINAPI_PARTITION_GAMES = 1;

const int WINAPI_PARTITION_SYSTEM = 0;

const int WINAPI_PARTITION_PHONE = 0;

const int GL_VERSION_1_1 = 1;

const int GL_ACCUM = 256;

const int GL_LOAD = 257;

const int GL_RETURN = 258;

const int GL_MULT = 259;

const int GL_ADD = 260;

const int GL_NEVER = 512;

const int GL_LESS = 513;

const int GL_EQUAL = 514;

const int GL_LEQUAL = 515;

const int GL_GREATER = 516;

const int GL_NOTEQUAL = 517;

const int GL_GEQUAL = 518;

const int GL_ALWAYS = 519;

const int GL_CURRENT_BIT = 1;

const int GL_POINT_BIT = 2;

const int GL_LINE_BIT = 4;

const int GL_POLYGON_BIT = 8;

const int GL_POLYGON_STIPPLE_BIT = 16;

const int GL_PIXEL_MODE_BIT = 32;

const int GL_LIGHTING_BIT = 64;

const int GL_FOG_BIT = 128;

const int GL_DEPTH_BUFFER_BIT = 256;

const int GL_ACCUM_BUFFER_BIT = 512;

const int GL_STENCIL_BUFFER_BIT = 1024;

const int GL_VIEWPORT_BIT = 2048;

const int GL_TRANSFORM_BIT = 4096;

const int GL_ENABLE_BIT = 8192;

const int GL_COLOR_BUFFER_BIT = 16384;

const int GL_HINT_BIT = 32768;

const int GL_EVAL_BIT = 65536;

const int GL_LIST_BIT = 131072;

const int GL_TEXTURE_BIT = 262144;

const int GL_SCISSOR_BIT = 524288;

const int GL_ALL_ATTRIB_BITS = 1048575;

const int GL_POINTS = 0;

const int GL_LINES = 1;

const int GL_LINE_LOOP = 2;

const int GL_LINE_STRIP = 3;

const int GL_TRIANGLES = 4;

const int GL_TRIANGLE_STRIP = 5;

const int GL_TRIANGLE_FAN = 6;

const int GL_QUADS = 7;

const int GL_QUAD_STRIP = 8;

const int GL_POLYGON = 9;

const int GL_ZERO = 0;

const int GL_ONE = 1;

const int GL_SRC_COLOR = 768;

const int GL_ONE_MINUS_SRC_COLOR = 769;

const int GL_SRC_ALPHA = 770;

const int GL_ONE_MINUS_SRC_ALPHA = 771;

const int GL_DST_ALPHA = 772;

const int GL_ONE_MINUS_DST_ALPHA = 773;

const int GL_DST_COLOR = 774;

const int GL_ONE_MINUS_DST_COLOR = 775;

const int GL_SRC_ALPHA_SATURATE = 776;

const int GL_TRUE = 1;

const int GL_FALSE = 0;

const int GL_CLIP_PLANE0 = 12288;

const int GL_CLIP_PLANE1 = 12289;

const int GL_CLIP_PLANE2 = 12290;

const int GL_CLIP_PLANE3 = 12291;

const int GL_CLIP_PLANE4 = 12292;

const int GL_CLIP_PLANE5 = 12293;

const int GL_BYTE = 5120;

const int GL_UNSIGNED_BYTE = 5121;

const int GL_SHORT = 5122;

const int GL_UNSIGNED_SHORT = 5123;

const int GL_INT = 5124;

const int GL_UNSIGNED_INT = 5125;

const int GL_FLOAT = 5126;

const int GL_2_BYTES = 5127;

const int GL_3_BYTES = 5128;

const int GL_4_BYTES = 5129;

const int GL_DOUBLE = 5130;

const int GL_NONE = 0;

const int GL_FRONT_LEFT = 1024;

const int GL_FRONT_RIGHT = 1025;

const int GL_BACK_LEFT = 1026;

const int GL_BACK_RIGHT = 1027;

const int GL_FRONT = 1028;

const int GL_BACK = 1029;

const int GL_LEFT = 1030;

const int GL_RIGHT = 1031;

const int GL_FRONT_AND_BACK = 1032;

const int GL_AUX0 = 1033;

const int GL_AUX1 = 1034;

const int GL_AUX2 = 1035;

const int GL_AUX3 = 1036;

const int GL_NO_ERROR = 0;

const int GL_INVALID_ENUM = 1280;

const int GL_INVALID_VALUE = 1281;

const int GL_INVALID_OPERATION = 1282;

const int GL_STACK_OVERFLOW = 1283;

const int GL_STACK_UNDERFLOW = 1284;

const int GL_OUT_OF_MEMORY = 1285;

const int GL_2D = 1536;

const int GL_3D = 1537;

const int GL_3D_COLOR = 1538;

const int GL_3D_COLOR_TEXTURE = 1539;

const int GL_4D_COLOR_TEXTURE = 1540;

const int GL_PASS_THROUGH_TOKEN = 1792;

const int GL_POINT_TOKEN = 1793;

const int GL_LINE_TOKEN = 1794;

const int GL_POLYGON_TOKEN = 1795;

const int GL_BITMAP_TOKEN = 1796;

const int GL_DRAW_PIXEL_TOKEN = 1797;

const int GL_COPY_PIXEL_TOKEN = 1798;

const int GL_LINE_RESET_TOKEN = 1799;

const int GL_EXP = 2048;

const int GL_EXP2 = 2049;

const int GL_CW = 2304;

const int GL_CCW = 2305;

const int GL_COEFF = 2560;

const int GL_ORDER = 2561;

const int GL_DOMAIN = 2562;

const int GL_CURRENT_COLOR = 2816;

const int GL_CURRENT_INDEX = 2817;

const int GL_CURRENT_NORMAL = 2818;

const int GL_CURRENT_TEXTURE_COORDS = 2819;

const int GL_CURRENT_RASTER_COLOR = 2820;

const int GL_CURRENT_RASTER_INDEX = 2821;

const int GL_CURRENT_RASTER_TEXTURE_COORDS = 2822;

const int GL_CURRENT_RASTER_POSITION = 2823;

const int GL_CURRENT_RASTER_POSITION_VALID = 2824;

const int GL_CURRENT_RASTER_DISTANCE = 2825;

const int GL_POINT_SMOOTH = 2832;

const int GL_POINT_SIZE = 2833;

const int GL_POINT_SIZE_RANGE = 2834;

const int GL_POINT_SIZE_GRANULARITY = 2835;

const int GL_LINE_SMOOTH = 2848;

const int GL_LINE_WIDTH = 2849;

const int GL_LINE_WIDTH_RANGE = 2850;

const int GL_LINE_WIDTH_GRANULARITY = 2851;

const int GL_LINE_STIPPLE = 2852;

const int GL_LINE_STIPPLE_PATTERN = 2853;

const int GL_LINE_STIPPLE_REPEAT = 2854;

const int GL_LIST_MODE = 2864;

const int GL_MAX_LIST_NESTING = 2865;

const int GL_LIST_BASE = 2866;

const int GL_LIST_INDEX = 2867;

const int GL_POLYGON_MODE = 2880;

const int GL_POLYGON_SMOOTH = 2881;

const int GL_POLYGON_STIPPLE = 2882;

const int GL_EDGE_FLAG = 2883;

const int GL_CULL_FACE = 2884;

const int GL_CULL_FACE_MODE = 2885;

const int GL_FRONT_FACE = 2886;

const int GL_LIGHTING = 2896;

const int GL_LIGHT_MODEL_LOCAL_VIEWER = 2897;

const int GL_LIGHT_MODEL_TWO_SIDE = 2898;

const int GL_LIGHT_MODEL_AMBIENT = 2899;

const int GL_SHADE_MODEL = 2900;

const int GL_COLOR_MATERIAL_FACE = 2901;

const int GL_COLOR_MATERIAL_PARAMETER = 2902;

const int GL_COLOR_MATERIAL = 2903;

const int GL_FOG = 2912;

const int GL_FOG_INDEX = 2913;

const int GL_FOG_DENSITY = 2914;

const int GL_FOG_START = 2915;

const int GL_FOG_END = 2916;

const int GL_FOG_MODE = 2917;

const int GL_FOG_COLOR = 2918;

const int GL_DEPTH_RANGE = 2928;

const int GL_DEPTH_TEST = 2929;

const int GL_DEPTH_WRITEMASK = 2930;

const int GL_DEPTH_CLEAR_VALUE = 2931;

const int GL_DEPTH_FUNC = 2932;

const int GL_ACCUM_CLEAR_VALUE = 2944;

const int GL_STENCIL_TEST = 2960;

const int GL_STENCIL_CLEAR_VALUE = 2961;

const int GL_STENCIL_FUNC = 2962;

const int GL_STENCIL_VALUE_MASK = 2963;

const int GL_STENCIL_FAIL = 2964;

const int GL_STENCIL_PASS_DEPTH_FAIL = 2965;

const int GL_STENCIL_PASS_DEPTH_PASS = 2966;

const int GL_STENCIL_REF = 2967;

const int GL_STENCIL_WRITEMASK = 2968;

const int GL_MATRIX_MODE = 2976;

const int GL_NORMALIZE = 2977;

const int GL_VIEWPORT = 2978;

const int GL_MODELVIEW_STACK_DEPTH = 2979;

const int GL_PROJECTION_STACK_DEPTH = 2980;

const int GL_TEXTURE_STACK_DEPTH = 2981;

const int GL_MODELVIEW_MATRIX = 2982;

const int GL_PROJECTION_MATRIX = 2983;

const int GL_TEXTURE_MATRIX = 2984;

const int GL_ATTRIB_STACK_DEPTH = 2992;

const int GL_CLIENT_ATTRIB_STACK_DEPTH = 2993;

const int GL_ALPHA_TEST = 3008;

const int GL_ALPHA_TEST_FUNC = 3009;

const int GL_ALPHA_TEST_REF = 3010;

const int GL_DITHER = 3024;

const int GL_BLEND_DST = 3040;

const int GL_BLEND_SRC = 3041;

const int GL_BLEND = 3042;

const int GL_LOGIC_OP_MODE = 3056;

const int GL_INDEX_LOGIC_OP = 3057;

const int GL_COLOR_LOGIC_OP = 3058;

const int GL_AUX_BUFFERS = 3072;

const int GL_DRAW_BUFFER = 3073;

const int GL_READ_BUFFER = 3074;

const int GL_SCISSOR_BOX = 3088;

const int GL_SCISSOR_TEST = 3089;

const int GL_INDEX_CLEAR_VALUE = 3104;

const int GL_INDEX_WRITEMASK = 3105;

const int GL_COLOR_CLEAR_VALUE = 3106;

const int GL_COLOR_WRITEMASK = 3107;

const int GL_INDEX_MODE = 3120;

const int GL_RGBA_MODE = 3121;

const int GL_DOUBLEBUFFER = 3122;

const int GL_STEREO = 3123;

const int GL_RENDER_MODE = 3136;

const int GL_PERSPECTIVE_CORRECTION_HINT = 3152;

const int GL_POINT_SMOOTH_HINT = 3153;

const int GL_LINE_SMOOTH_HINT = 3154;

const int GL_POLYGON_SMOOTH_HINT = 3155;

const int GL_FOG_HINT = 3156;

const int GL_TEXTURE_GEN_S = 3168;

const int GL_TEXTURE_GEN_T = 3169;

const int GL_TEXTURE_GEN_R = 3170;

const int GL_TEXTURE_GEN_Q = 3171;

const int GL_PIXEL_MAP_I_TO_I = 3184;

const int GL_PIXEL_MAP_S_TO_S = 3185;

const int GL_PIXEL_MAP_I_TO_R = 3186;

const int GL_PIXEL_MAP_I_TO_G = 3187;

const int GL_PIXEL_MAP_I_TO_B = 3188;

const int GL_PIXEL_MAP_I_TO_A = 3189;

const int GL_PIXEL_MAP_R_TO_R = 3190;

const int GL_PIXEL_MAP_G_TO_G = 3191;

const int GL_PIXEL_MAP_B_TO_B = 3192;

const int GL_PIXEL_MAP_A_TO_A = 3193;

const int GL_PIXEL_MAP_I_TO_I_SIZE = 3248;

const int GL_PIXEL_MAP_S_TO_S_SIZE = 3249;

const int GL_PIXEL_MAP_I_TO_R_SIZE = 3250;

const int GL_PIXEL_MAP_I_TO_G_SIZE = 3251;

const int GL_PIXEL_MAP_I_TO_B_SIZE = 3252;

const int GL_PIXEL_MAP_I_TO_A_SIZE = 3253;

const int GL_PIXEL_MAP_R_TO_R_SIZE = 3254;

const int GL_PIXEL_MAP_G_TO_G_SIZE = 3255;

const int GL_PIXEL_MAP_B_TO_B_SIZE = 3256;

const int GL_PIXEL_MAP_A_TO_A_SIZE = 3257;

const int GL_UNPACK_SWAP_BYTES = 3312;

const int GL_UNPACK_LSB_FIRST = 3313;

const int GL_UNPACK_ROW_LENGTH = 3314;

const int GL_UNPACK_SKIP_ROWS = 3315;

const int GL_UNPACK_SKIP_PIXELS = 3316;

const int GL_UNPACK_ALIGNMENT = 3317;

const int GL_PACK_SWAP_BYTES = 3328;

const int GL_PACK_LSB_FIRST = 3329;

const int GL_PACK_ROW_LENGTH = 3330;

const int GL_PACK_SKIP_ROWS = 3331;

const int GL_PACK_SKIP_PIXELS = 3332;

const int GL_PACK_ALIGNMENT = 3333;

const int GL_MAP_COLOR = 3344;

const int GL_MAP_STENCIL = 3345;

const int GL_INDEX_SHIFT = 3346;

const int GL_INDEX_OFFSET = 3347;

const int GL_RED_SCALE = 3348;

const int GL_RED_BIAS = 3349;

const int GL_ZOOM_X = 3350;

const int GL_ZOOM_Y = 3351;

const int GL_GREEN_SCALE = 3352;

const int GL_GREEN_BIAS = 3353;

const int GL_BLUE_SCALE = 3354;

const int GL_BLUE_BIAS = 3355;

const int GL_ALPHA_SCALE = 3356;

const int GL_ALPHA_BIAS = 3357;

const int GL_DEPTH_SCALE = 3358;

const int GL_DEPTH_BIAS = 3359;

const int GL_MAX_EVAL_ORDER = 3376;

const int GL_MAX_LIGHTS = 3377;

const int GL_MAX_CLIP_PLANES = 3378;

const int GL_MAX_TEXTURE_SIZE = 3379;

const int GL_MAX_PIXEL_MAP_TABLE = 3380;

const int GL_MAX_ATTRIB_STACK_DEPTH = 3381;

const int GL_MAX_MODELVIEW_STACK_DEPTH = 3382;

const int GL_MAX_NAME_STACK_DEPTH = 3383;

const int GL_MAX_PROJECTION_STACK_DEPTH = 3384;

const int GL_MAX_TEXTURE_STACK_DEPTH = 3385;

const int GL_MAX_VIEWPORT_DIMS = 3386;

const int GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 3387;

const int GL_SUBPIXEL_BITS = 3408;

const int GL_INDEX_BITS = 3409;

const int GL_RED_BITS = 3410;

const int GL_GREEN_BITS = 3411;

const int GL_BLUE_BITS = 3412;

const int GL_ALPHA_BITS = 3413;

const int GL_DEPTH_BITS = 3414;

const int GL_STENCIL_BITS = 3415;

const int GL_ACCUM_RED_BITS = 3416;

const int GL_ACCUM_GREEN_BITS = 3417;

const int GL_ACCUM_BLUE_BITS = 3418;

const int GL_ACCUM_ALPHA_BITS = 3419;

const int GL_NAME_STACK_DEPTH = 3440;

const int GL_AUTO_NORMAL = 3456;

const int GL_MAP1_COLOR_4 = 3472;

const int GL_MAP1_INDEX = 3473;

const int GL_MAP1_NORMAL = 3474;

const int GL_MAP1_TEXTURE_COORD_1 = 3475;

const int GL_MAP1_TEXTURE_COORD_2 = 3476;

const int GL_MAP1_TEXTURE_COORD_3 = 3477;

const int GL_MAP1_TEXTURE_COORD_4 = 3478;

const int GL_MAP1_VERTEX_3 = 3479;

const int GL_MAP1_VERTEX_4 = 3480;

const int GL_MAP2_COLOR_4 = 3504;

const int GL_MAP2_INDEX = 3505;

const int GL_MAP2_NORMAL = 3506;

const int GL_MAP2_TEXTURE_COORD_1 = 3507;

const int GL_MAP2_TEXTURE_COORD_2 = 3508;

const int GL_MAP2_TEXTURE_COORD_3 = 3509;

const int GL_MAP2_TEXTURE_COORD_4 = 3510;

const int GL_MAP2_VERTEX_3 = 3511;

const int GL_MAP2_VERTEX_4 = 3512;

const int GL_MAP1_GRID_DOMAIN = 3536;

const int GL_MAP1_GRID_SEGMENTS = 3537;

const int GL_MAP2_GRID_DOMAIN = 3538;

const int GL_MAP2_GRID_SEGMENTS = 3539;

const int GL_TEXTURE_1D = 3552;

const int GL_TEXTURE_2D = 3553;

const int GL_FEEDBACK_BUFFER_POINTER = 3568;

const int GL_FEEDBACK_BUFFER_SIZE = 3569;

const int GL_FEEDBACK_BUFFER_TYPE = 3570;

const int GL_SELECTION_BUFFER_POINTER = 3571;

const int GL_SELECTION_BUFFER_SIZE = 3572;

const int GL_TEXTURE_WIDTH = 4096;

const int GL_TEXTURE_HEIGHT = 4097;

const int GL_TEXTURE_INTERNAL_FORMAT = 4099;

const int GL_TEXTURE_BORDER_COLOR = 4100;

const int GL_TEXTURE_BORDER = 4101;

const int GL_DONT_CARE = 4352;

const int GL_FASTEST = 4353;

const int GL_NICEST = 4354;

const int GL_LIGHT0 = 16384;

const int GL_LIGHT1 = 16385;

const int GL_LIGHT2 = 16386;

const int GL_LIGHT3 = 16387;

const int GL_LIGHT4 = 16388;

const int GL_LIGHT5 = 16389;

const int GL_LIGHT6 = 16390;

const int GL_LIGHT7 = 16391;

const int GL_AMBIENT = 4608;

const int GL_DIFFUSE = 4609;

const int GL_SPECULAR = 4610;

const int GL_POSITION = 4611;

const int GL_SPOT_DIRECTION = 4612;

const int GL_SPOT_EXPONENT = 4613;

const int GL_SPOT_CUTOFF = 4614;

const int GL_CONSTANT_ATTENUATION = 4615;

const int GL_LINEAR_ATTENUATION = 4616;

const int GL_QUADRATIC_ATTENUATION = 4617;

const int GL_COMPILE = 4864;

const int GL_COMPILE_AND_EXECUTE = 4865;

const int GL_CLEAR = 5376;

const int GL_AND = 5377;

const int GL_AND_REVERSE = 5378;

const int GL_COPY = 5379;

const int GL_AND_INVERTED = 5380;

const int GL_NOOP = 5381;

const int GL_XOR = 5382;

const int GL_OR = 5383;

const int GL_NOR = 5384;

const int GL_EQUIV = 5385;

const int GL_INVERT = 5386;

const int GL_OR_REVERSE = 5387;

const int GL_COPY_INVERTED = 5388;

const int GL_OR_INVERTED = 5389;

const int GL_NAND = 5390;

const int GL_SET = 5391;

const int GL_EMISSION = 5632;

const int GL_SHININESS = 5633;

const int GL_AMBIENT_AND_DIFFUSE = 5634;

const int GL_COLOR_INDEXES = 5635;

const int GL_MODELVIEW = 5888;

const int GL_PROJECTION = 5889;

const int GL_TEXTURE = 5890;

const int GL_COLOR = 6144;

const int GL_DEPTH = 6145;

const int GL_STENCIL = 6146;

const int GL_COLOR_INDEX = 6400;

const int GL_STENCIL_INDEX = 6401;

const int GL_DEPTH_COMPONENT = 6402;

const int GL_RED = 6403;

const int GL_GREEN = 6404;

const int GL_BLUE = 6405;

const int GL_ALPHA = 6406;

const int GL_RGB = 6407;

const int GL_RGBA = 6408;

const int GL_LUMINANCE = 6409;

const int GL_LUMINANCE_ALPHA = 6410;

const int GL_BITMAP = 6656;

const int GL_POINT = 6912;

const int GL_LINE = 6913;

const int GL_FILL = 6914;

const int GL_RENDER = 7168;

const int GL_FEEDBACK = 7169;

const int GL_SELECT = 7170;

const int GL_FLAT = 7424;

const int GL_SMOOTH = 7425;

const int GL_KEEP = 7680;

const int GL_REPLACE = 7681;

const int GL_INCR = 7682;

const int GL_DECR = 7683;

const int GL_VENDOR = 7936;

const int GL_RENDERER = 7937;

const int GL_VERSION = 7938;

const int GL_EXTENSIONS = 7939;

const int GL_S = 8192;

const int GL_T = 8193;

const int GL_R = 8194;

const int GL_Q = 8195;

const int GL_MODULATE = 8448;

const int GL_DECAL = 8449;

const int GL_TEXTURE_ENV_MODE = 8704;

const int GL_TEXTURE_ENV_COLOR = 8705;

const int GL_TEXTURE_ENV = 8960;

const int GL_EYE_LINEAR = 9216;

const int GL_OBJECT_LINEAR = 9217;

const int GL_SPHERE_MAP = 9218;

const int GL_TEXTURE_GEN_MODE = 9472;

const int GL_OBJECT_PLANE = 9473;

const int GL_EYE_PLANE = 9474;

const int GL_NEAREST = 9728;

const int GL_LINEAR = 9729;

const int GL_NEAREST_MIPMAP_NEAREST = 9984;

const int GL_LINEAR_MIPMAP_NEAREST = 9985;

const int GL_NEAREST_MIPMAP_LINEAR = 9986;

const int GL_LINEAR_MIPMAP_LINEAR = 9987;

const int GL_TEXTURE_MAG_FILTER = 10240;

const int GL_TEXTURE_MIN_FILTER = 10241;

const int GL_TEXTURE_WRAP_S = 10242;

const int GL_TEXTURE_WRAP_T = 10243;

const int GL_CLAMP = 10496;

const int GL_REPEAT = 10497;

const int GL_CLIENT_PIXEL_STORE_BIT = 1;

const int GL_CLIENT_VERTEX_ARRAY_BIT = 2;

const int GL_CLIENT_ALL_ATTRIB_BITS = 4294967295;

const int GL_POLYGON_OFFSET_FACTOR = 32824;

const int GL_POLYGON_OFFSET_UNITS = 10752;

const int GL_POLYGON_OFFSET_POINT = 10753;

const int GL_POLYGON_OFFSET_LINE = 10754;

const int GL_POLYGON_OFFSET_FILL = 32823;

const int GL_ALPHA4 = 32827;

const int GL_ALPHA8 = 32828;

const int GL_ALPHA12 = 32829;

const int GL_ALPHA16 = 32830;

const int GL_LUMINANCE4 = 32831;

const int GL_LUMINANCE8 = 32832;

const int GL_LUMINANCE12 = 32833;

const int GL_LUMINANCE16 = 32834;

const int GL_LUMINANCE4_ALPHA4 = 32835;

const int GL_LUMINANCE6_ALPHA2 = 32836;

const int GL_LUMINANCE8_ALPHA8 = 32837;

const int GL_LUMINANCE12_ALPHA4 = 32838;

const int GL_LUMINANCE12_ALPHA12 = 32839;

const int GL_LUMINANCE16_ALPHA16 = 32840;

const int GL_INTENSITY = 32841;

const int GL_INTENSITY4 = 32842;

const int GL_INTENSITY8 = 32843;

const int GL_INTENSITY12 = 32844;

const int GL_INTENSITY16 = 32845;

const int GL_R3_G3_B2 = 10768;

const int GL_RGB4 = 32847;

const int GL_RGB5 = 32848;

const int GL_RGB8 = 32849;

const int GL_RGB10 = 32850;

const int GL_RGB12 = 32851;

const int GL_RGB16 = 32852;

const int GL_RGBA2 = 32853;

const int GL_RGBA4 = 32854;

const int GL_RGB5_A1 = 32855;

const int GL_RGBA8 = 32856;

const int GL_RGB10_A2 = 32857;

const int GL_RGBA12 = 32858;

const int GL_RGBA16 = 32859;

const int GL_TEXTURE_RED_SIZE = 32860;

const int GL_TEXTURE_GREEN_SIZE = 32861;

const int GL_TEXTURE_BLUE_SIZE = 32862;

const int GL_TEXTURE_ALPHA_SIZE = 32863;

const int GL_TEXTURE_LUMINANCE_SIZE = 32864;

const int GL_TEXTURE_INTENSITY_SIZE = 32865;

const int GL_PROXY_TEXTURE_1D = 32867;

const int GL_PROXY_TEXTURE_2D = 32868;

const int GL_TEXTURE_PRIORITY = 32870;

const int GL_TEXTURE_RESIDENT = 32871;

const int GL_TEXTURE_BINDING_1D = 32872;

const int GL_TEXTURE_BINDING_2D = 32873;

const int GL_VERTEX_ARRAY = 32884;

const int GL_NORMAL_ARRAY = 32885;

const int GL_COLOR_ARRAY = 32886;

const int GL_INDEX_ARRAY = 32887;

const int GL_TEXTURE_COORD_ARRAY = 32888;

const int GL_EDGE_FLAG_ARRAY = 32889;

const int GL_VERTEX_ARRAY_SIZE = 32890;

const int GL_VERTEX_ARRAY_TYPE = 32891;

const int GL_VERTEX_ARRAY_STRIDE = 32892;

const int GL_NORMAL_ARRAY_TYPE = 32894;

const int GL_NORMAL_ARRAY_STRIDE = 32895;

const int GL_COLOR_ARRAY_SIZE = 32897;

const int GL_COLOR_ARRAY_TYPE = 32898;

const int GL_COLOR_ARRAY_STRIDE = 32899;

const int GL_INDEX_ARRAY_TYPE = 32901;

const int GL_INDEX_ARRAY_STRIDE = 32902;

const int GL_TEXTURE_COORD_ARRAY_SIZE = 32904;

const int GL_TEXTURE_COORD_ARRAY_TYPE = 32905;

const int GL_TEXTURE_COORD_ARRAY_STRIDE = 32906;

const int GL_EDGE_FLAG_ARRAY_STRIDE = 32908;

const int GL_VERTEX_ARRAY_POINTER = 32910;

const int GL_NORMAL_ARRAY_POINTER = 32911;

const int GL_COLOR_ARRAY_POINTER = 32912;

const int GL_INDEX_ARRAY_POINTER = 32913;

const int GL_TEXTURE_COORD_ARRAY_POINTER = 32914;

const int GL_EDGE_FLAG_ARRAY_POINTER = 32915;

const int GL_V2F = 10784;

const int GL_V3F = 10785;

const int GL_C4UB_V2F = 10786;

const int GL_C4UB_V3F = 10787;

const int GL_C3F_V3F = 10788;

const int GL_N3F_V3F = 10789;

const int GL_C4F_N3F_V3F = 10790;

const int GL_T2F_V3F = 10791;

const int GL_T4F_V4F = 10792;

const int GL_T2F_C4UB_V3F = 10793;

const int GL_T2F_C3F_V3F = 10794;

const int GL_T2F_N3F_V3F = 10795;

const int GL_T2F_C4F_N3F_V3F = 10796;

const int GL_T4F_C4F_N3F_V4F = 10797;

const int GL_EXT_vertex_array = 1;

const int GL_EXT_bgra = 1;

const int GL_EXT_paletted_texture = 1;

const int GL_WIN_swap_hint = 1;

const int GL_WIN_draw_range_elements = 1;

const int GL_VERTEX_ARRAY_EXT = 32884;

const int GL_NORMAL_ARRAY_EXT = 32885;

const int GL_COLOR_ARRAY_EXT = 32886;

const int GL_INDEX_ARRAY_EXT = 32887;

const int GL_TEXTURE_COORD_ARRAY_EXT = 32888;

const int GL_EDGE_FLAG_ARRAY_EXT = 32889;

const int GL_VERTEX_ARRAY_SIZE_EXT = 32890;

const int GL_VERTEX_ARRAY_TYPE_EXT = 32891;

const int GL_VERTEX_ARRAY_STRIDE_EXT = 32892;

const int GL_VERTEX_ARRAY_COUNT_EXT = 32893;

const int GL_NORMAL_ARRAY_TYPE_EXT = 32894;

const int GL_NORMAL_ARRAY_STRIDE_EXT = 32895;

const int GL_NORMAL_ARRAY_COUNT_EXT = 32896;

const int GL_COLOR_ARRAY_SIZE_EXT = 32897;

const int GL_COLOR_ARRAY_TYPE_EXT = 32898;

const int GL_COLOR_ARRAY_STRIDE_EXT = 32899;

const int GL_COLOR_ARRAY_COUNT_EXT = 32900;

const int GL_INDEX_ARRAY_TYPE_EXT = 32901;

const int GL_INDEX_ARRAY_STRIDE_EXT = 32902;

const int GL_INDEX_ARRAY_COUNT_EXT = 32903;

const int GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 32904;

const int GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 32905;

const int GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 32906;

const int GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 32907;

const int GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 32908;

const int GL_EDGE_FLAG_ARRAY_COUNT_EXT = 32909;

const int GL_VERTEX_ARRAY_POINTER_EXT = 32910;

const int GL_NORMAL_ARRAY_POINTER_EXT = 32911;

const int GL_COLOR_ARRAY_POINTER_EXT = 32912;

const int GL_INDEX_ARRAY_POINTER_EXT = 32913;

const int GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 32914;

const int GL_EDGE_FLAG_ARRAY_POINTER_EXT = 32915;

const int GL_DOUBLE_EXT = 5130;

const int GL_BGR_EXT = 32992;

const int GL_BGRA_EXT = 32993;

const int GL_COLOR_TABLE_FORMAT_EXT = 32984;

const int GL_COLOR_TABLE_WIDTH_EXT = 32985;

const int GL_COLOR_TABLE_RED_SIZE_EXT = 32986;

const int GL_COLOR_TABLE_GREEN_SIZE_EXT = 32987;

const int GL_COLOR_TABLE_BLUE_SIZE_EXT = 32988;

const int GL_COLOR_TABLE_ALPHA_SIZE_EXT = 32989;

const int GL_COLOR_TABLE_LUMINANCE_SIZE_EXT = 32990;

const int GL_COLOR_TABLE_INTENSITY_SIZE_EXT = 32991;

const int GL_COLOR_INDEX1_EXT = 32994;

const int GL_COLOR_INDEX2_EXT = 32995;

const int GL_COLOR_INDEX4_EXT = 32996;

const int GL_COLOR_INDEX8_EXT = 32997;

const int GL_COLOR_INDEX12_EXT = 32998;

const int GL_COLOR_INDEX16_EXT = 32999;

const int GL_MAX_ELEMENTS_VERTICES_WIN = 33000;

const int GL_MAX_ELEMENTS_INDICES_WIN = 33001;

const int GL_PHONG_WIN = 33002;

const int GL_PHONG_HINT_WIN = 33003;

const int GL_FOG_SPECULAR_TEXTURE_WIN = 33004;

const int GL_LOGIC_OP = 3057;

const int GL_TEXTURE_COMPONENTS = 4099;

const int GLFW_VERSION_MAJOR = 3;

const int GLFW_VERSION_MINOR = 3;

const int GLFW_VERSION_REVISION = 5;

const int GLFW_TRUE = 1;

const int GLFW_FALSE = 0;

const int GLFW_RELEASE = 0;

const int GLFW_PRESS = 1;

const int GLFW_REPEAT = 2;

const int GLFW_HAT_CENTERED = 0;

const int GLFW_HAT_UP = 1;

const int GLFW_HAT_RIGHT = 2;

const int GLFW_HAT_DOWN = 4;

const int GLFW_HAT_LEFT = 8;

const int GLFW_HAT_RIGHT_UP = 3;

const int GLFW_HAT_RIGHT_DOWN = 6;

const int GLFW_HAT_LEFT_UP = 9;

const int GLFW_HAT_LEFT_DOWN = 12;

const int GLFW_KEY_UNKNOWN = -1;

const int GLFW_KEY_SPACE = 32;

const int GLFW_KEY_APOSTROPHE = 39;

const int GLFW_KEY_COMMA = 44;

const int GLFW_KEY_MINUS = 45;

const int GLFW_KEY_PERIOD = 46;

const int GLFW_KEY_SLASH = 47;

const int GLFW_KEY_0 = 48;

const int GLFW_KEY_1 = 49;

const int GLFW_KEY_2 = 50;

const int GLFW_KEY_3 = 51;

const int GLFW_KEY_4 = 52;

const int GLFW_KEY_5 = 53;

const int GLFW_KEY_6 = 54;

const int GLFW_KEY_7 = 55;

const int GLFW_KEY_8 = 56;

const int GLFW_KEY_9 = 57;

const int GLFW_KEY_SEMICOLON = 59;

const int GLFW_KEY_EQUAL = 61;

const int GLFW_KEY_A = 65;

const int GLFW_KEY_B = 66;

const int GLFW_KEY_C = 67;

const int GLFW_KEY_D = 68;

const int GLFW_KEY_E = 69;

const int GLFW_KEY_F = 70;

const int GLFW_KEY_G = 71;

const int GLFW_KEY_H = 72;

const int GLFW_KEY_I = 73;

const int GLFW_KEY_J = 74;

const int GLFW_KEY_K = 75;

const int GLFW_KEY_L = 76;

const int GLFW_KEY_M = 77;

const int GLFW_KEY_N = 78;

const int GLFW_KEY_O = 79;

const int GLFW_KEY_P = 80;

const int GLFW_KEY_Q = 81;

const int GLFW_KEY_R = 82;

const int GLFW_KEY_S = 83;

const int GLFW_KEY_T = 84;

const int GLFW_KEY_U = 85;

const int GLFW_KEY_V = 86;

const int GLFW_KEY_W = 87;

const int GLFW_KEY_X = 88;

const int GLFW_KEY_Y = 89;

const int GLFW_KEY_Z = 90;

const int GLFW_KEY_LEFT_BRACKET = 91;

const int GLFW_KEY_BACKSLASH = 92;

const int GLFW_KEY_RIGHT_BRACKET = 93;

const int GLFW_KEY_GRAVE_ACCENT = 96;

const int GLFW_KEY_WORLD_1 = 161;

const int GLFW_KEY_WORLD_2 = 162;

const int GLFW_KEY_ESCAPE = 256;

const int GLFW_KEY_ENTER = 257;

const int GLFW_KEY_TAB = 258;

const int GLFW_KEY_BACKSPACE = 259;

const int GLFW_KEY_INSERT = 260;

const int GLFW_KEY_DELETE = 261;

const int GLFW_KEY_RIGHT = 262;

const int GLFW_KEY_LEFT = 263;

const int GLFW_KEY_DOWN = 264;

const int GLFW_KEY_UP = 265;

const int GLFW_KEY_PAGE_UP = 266;

const int GLFW_KEY_PAGE_DOWN = 267;

const int GLFW_KEY_HOME = 268;

const int GLFW_KEY_END = 269;

const int GLFW_KEY_CAPS_LOCK = 280;

const int GLFW_KEY_SCROLL_LOCK = 281;

const int GLFW_KEY_NUM_LOCK = 282;

const int GLFW_KEY_PRINT_SCREEN = 283;

const int GLFW_KEY_PAUSE = 284;

const int GLFW_KEY_F1 = 290;

const int GLFW_KEY_F2 = 291;

const int GLFW_KEY_F3 = 292;

const int GLFW_KEY_F4 = 293;

const int GLFW_KEY_F5 = 294;

const int GLFW_KEY_F6 = 295;

const int GLFW_KEY_F7 = 296;

const int GLFW_KEY_F8 = 297;

const int GLFW_KEY_F9 = 298;

const int GLFW_KEY_F10 = 299;

const int GLFW_KEY_F11 = 300;

const int GLFW_KEY_F12 = 301;

const int GLFW_KEY_F13 = 302;

const int GLFW_KEY_F14 = 303;

const int GLFW_KEY_F15 = 304;

const int GLFW_KEY_F16 = 305;

const int GLFW_KEY_F17 = 306;

const int GLFW_KEY_F18 = 307;

const int GLFW_KEY_F19 = 308;

const int GLFW_KEY_F20 = 309;

const int GLFW_KEY_F21 = 310;

const int GLFW_KEY_F22 = 311;

const int GLFW_KEY_F23 = 312;

const int GLFW_KEY_F24 = 313;

const int GLFW_KEY_F25 = 314;

const int GLFW_KEY_KP_0 = 320;

const int GLFW_KEY_KP_1 = 321;

const int GLFW_KEY_KP_2 = 322;

const int GLFW_KEY_KP_3 = 323;

const int GLFW_KEY_KP_4 = 324;

const int GLFW_KEY_KP_5 = 325;

const int GLFW_KEY_KP_6 = 326;

const int GLFW_KEY_KP_7 = 327;

const int GLFW_KEY_KP_8 = 328;

const int GLFW_KEY_KP_9 = 329;

const int GLFW_KEY_KP_DECIMAL = 330;

const int GLFW_KEY_KP_DIVIDE = 331;

const int GLFW_KEY_KP_MULTIPLY = 332;

const int GLFW_KEY_KP_SUBTRACT = 333;

const int GLFW_KEY_KP_ADD = 334;

const int GLFW_KEY_KP_ENTER = 335;

const int GLFW_KEY_KP_EQUAL = 336;

const int GLFW_KEY_LEFT_SHIFT = 340;

const int GLFW_KEY_LEFT_CONTROL = 341;

const int GLFW_KEY_LEFT_ALT = 342;

const int GLFW_KEY_LEFT_SUPER = 343;

const int GLFW_KEY_RIGHT_SHIFT = 344;

const int GLFW_KEY_RIGHT_CONTROL = 345;

const int GLFW_KEY_RIGHT_ALT = 346;

const int GLFW_KEY_RIGHT_SUPER = 347;

const int GLFW_KEY_MENU = 348;

const int GLFW_KEY_LAST = 348;

const int GLFW_MOD_SHIFT = 1;

const int GLFW_MOD_CONTROL = 2;

const int GLFW_MOD_ALT = 4;

const int GLFW_MOD_SUPER = 8;

const int GLFW_MOD_CAPS_LOCK = 16;

const int GLFW_MOD_NUM_LOCK = 32;

const int GLFW_MOUSE_BUTTON_1 = 0;

const int GLFW_MOUSE_BUTTON_2 = 1;

const int GLFW_MOUSE_BUTTON_3 = 2;

const int GLFW_MOUSE_BUTTON_4 = 3;

const int GLFW_MOUSE_BUTTON_5 = 4;

const int GLFW_MOUSE_BUTTON_6 = 5;

const int GLFW_MOUSE_BUTTON_7 = 6;

const int GLFW_MOUSE_BUTTON_8 = 7;

const int GLFW_MOUSE_BUTTON_LAST = 7;

const int GLFW_MOUSE_BUTTON_LEFT = 0;

const int GLFW_MOUSE_BUTTON_RIGHT = 1;

const int GLFW_MOUSE_BUTTON_MIDDLE = 2;

const int GLFW_JOYSTICK_1 = 0;

const int GLFW_JOYSTICK_2 = 1;

const int GLFW_JOYSTICK_3 = 2;

const int GLFW_JOYSTICK_4 = 3;

const int GLFW_JOYSTICK_5 = 4;

const int GLFW_JOYSTICK_6 = 5;

const int GLFW_JOYSTICK_7 = 6;

const int GLFW_JOYSTICK_8 = 7;

const int GLFW_JOYSTICK_9 = 8;

const int GLFW_JOYSTICK_10 = 9;

const int GLFW_JOYSTICK_11 = 10;

const int GLFW_JOYSTICK_12 = 11;

const int GLFW_JOYSTICK_13 = 12;

const int GLFW_JOYSTICK_14 = 13;

const int GLFW_JOYSTICK_15 = 14;

const int GLFW_JOYSTICK_16 = 15;

const int GLFW_JOYSTICK_LAST = 15;

const int GLFW_GAMEPAD_BUTTON_A = 0;

const int GLFW_GAMEPAD_BUTTON_B = 1;

const int GLFW_GAMEPAD_BUTTON_X = 2;

const int GLFW_GAMEPAD_BUTTON_Y = 3;

const int GLFW_GAMEPAD_BUTTON_LEFT_BUMPER = 4;

const int GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER = 5;

const int GLFW_GAMEPAD_BUTTON_BACK = 6;

const int GLFW_GAMEPAD_BUTTON_START = 7;

const int GLFW_GAMEPAD_BUTTON_GUIDE = 8;

const int GLFW_GAMEPAD_BUTTON_LEFT_THUMB = 9;

const int GLFW_GAMEPAD_BUTTON_RIGHT_THUMB = 10;

const int GLFW_GAMEPAD_BUTTON_DPAD_UP = 11;

const int GLFW_GAMEPAD_BUTTON_DPAD_RIGHT = 12;

const int GLFW_GAMEPAD_BUTTON_DPAD_DOWN = 13;

const int GLFW_GAMEPAD_BUTTON_DPAD_LEFT = 14;

const int GLFW_GAMEPAD_BUTTON_LAST = 14;

const int GLFW_GAMEPAD_BUTTON_CROSS = 0;

const int GLFW_GAMEPAD_BUTTON_CIRCLE = 1;

const int GLFW_GAMEPAD_BUTTON_SQUARE = 2;

const int GLFW_GAMEPAD_BUTTON_TRIANGLE = 3;

const int GLFW_GAMEPAD_AXIS_LEFT_X = 0;

const int GLFW_GAMEPAD_AXIS_LEFT_Y = 1;

const int GLFW_GAMEPAD_AXIS_RIGHT_X = 2;

const int GLFW_GAMEPAD_AXIS_RIGHT_Y = 3;

const int GLFW_GAMEPAD_AXIS_LEFT_TRIGGER = 4;

const int GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER = 5;

const int GLFW_GAMEPAD_AXIS_LAST = 5;

const int GLFW_NO_ERROR = 0;

const int GLFW_NOT_INITIALIZED = 65537;

const int GLFW_NO_CURRENT_CONTEXT = 65538;

const int GLFW_INVALID_ENUM = 65539;

const int GLFW_INVALID_VALUE = 65540;

const int GLFW_OUT_OF_MEMORY = 65541;

const int GLFW_API_UNAVAILABLE = 65542;

const int GLFW_VERSION_UNAVAILABLE = 65543;

const int GLFW_PLATFORM_ERROR = 65544;

const int GLFW_FORMAT_UNAVAILABLE = 65545;

const int GLFW_NO_WINDOW_CONTEXT = 65546;

const int GLFW_FOCUSED = 131073;

const int GLFW_ICONIFIED = 131074;

const int GLFW_RESIZABLE = 131075;

const int GLFW_VISIBLE = 131076;

const int GLFW_DECORATED = 131077;

const int GLFW_AUTO_ICONIFY = 131078;

const int GLFW_FLOATING = 131079;

const int GLFW_MAXIMIZED = 131080;

const int GLFW_CENTER_CURSOR = 131081;

const int GLFW_TRANSPARENT_FRAMEBUFFER = 131082;

const int GLFW_HOVERED = 131083;

const int GLFW_FOCUS_ON_SHOW = 131084;

const int GLFW_RED_BITS = 135169;

const int GLFW_GREEN_BITS = 135170;

const int GLFW_BLUE_BITS = 135171;

const int GLFW_ALPHA_BITS = 135172;

const int GLFW_DEPTH_BITS = 135173;

const int GLFW_STENCIL_BITS = 135174;

const int GLFW_ACCUM_RED_BITS = 135175;

const int GLFW_ACCUM_GREEN_BITS = 135176;

const int GLFW_ACCUM_BLUE_BITS = 135177;

const int GLFW_ACCUM_ALPHA_BITS = 135178;

const int GLFW_AUX_BUFFERS = 135179;

const int GLFW_STEREO = 135180;

const int GLFW_SAMPLES = 135181;

const int GLFW_SRGB_CAPABLE = 135182;

const int GLFW_REFRESH_RATE = 135183;

const int GLFW_DOUBLEBUFFER = 135184;

const int GLFW_CLIENT_API = 139265;

const int GLFW_CONTEXT_VERSION_MAJOR = 139266;

const int GLFW_CONTEXT_VERSION_MINOR = 139267;

const int GLFW_CONTEXT_REVISION = 139268;

const int GLFW_CONTEXT_ROBUSTNESS = 139269;

const int GLFW_OPENGL_FORWARD_COMPAT = 139270;

const int GLFW_OPENGL_DEBUG_CONTEXT = 139271;

const int GLFW_OPENGL_PROFILE = 139272;

const int GLFW_CONTEXT_RELEASE_BEHAVIOR = 139273;

const int GLFW_CONTEXT_NO_ERROR = 139274;

const int GLFW_CONTEXT_CREATION_API = 139275;

const int GLFW_SCALE_TO_MONITOR = 139276;

const int GLFW_COCOA_RETINA_FRAMEBUFFER = 143361;

const int GLFW_COCOA_FRAME_NAME = 143362;

const int GLFW_COCOA_GRAPHICS_SWITCHING = 143363;

const int GLFW_X11_CLASS_NAME = 147457;

const int GLFW_X11_INSTANCE_NAME = 147458;

const int GLFW_NO_API = 0;

const int GLFW_OPENGL_API = 196609;

const int GLFW_OPENGL_ES_API = 196610;

const int GLFW_NO_ROBUSTNESS = 0;

const int GLFW_NO_RESET_NOTIFICATION = 200705;

const int GLFW_LOSE_CONTEXT_ON_RESET = 200706;

const int GLFW_OPENGL_ANY_PROFILE = 0;

const int GLFW_OPENGL_CORE_PROFILE = 204801;

const int GLFW_OPENGL_COMPAT_PROFILE = 204802;

const int GLFW_CURSOR = 208897;

const int GLFW_STICKY_KEYS = 208898;

const int GLFW_STICKY_MOUSE_BUTTONS = 208899;

const int GLFW_LOCK_KEY_MODS = 208900;

const int GLFW_RAW_MOUSE_MOTION = 208901;

const int GLFW_CURSOR_NORMAL = 212993;

const int GLFW_CURSOR_HIDDEN = 212994;

const int GLFW_CURSOR_DISABLED = 212995;

const int GLFW_ANY_RELEASE_BEHAVIOR = 0;

const int GLFW_RELEASE_BEHAVIOR_FLUSH = 217089;

const int GLFW_RELEASE_BEHAVIOR_NONE = 217090;

const int GLFW_NATIVE_CONTEXT_API = 221185;

const int GLFW_EGL_CONTEXT_API = 221186;

const int GLFW_OSMESA_CONTEXT_API = 221187;

const int GLFW_ARROW_CURSOR = 221185;

const int GLFW_IBEAM_CURSOR = 221186;

const int GLFW_CROSSHAIR_CURSOR = 221187;

const int GLFW_HAND_CURSOR = 221188;

const int GLFW_HRESIZE_CURSOR = 221189;

const int GLFW_VRESIZE_CURSOR = 221190;

const int GLFW_CONNECTED = 262145;

const int GLFW_DISCONNECTED = 262146;

const int GLFW_JOYSTICK_HAT_BUTTONS = 327681;

const int GLFW_COCOA_CHDIR_RESOURCES = 331777;

const int GLFW_COCOA_MENUBAR = 331778;

const int GLFW_DONT_CARE = -1;
